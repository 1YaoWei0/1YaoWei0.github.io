[{"title":"Difference Between Transfer Journal and Transfer Order D365 F&O","url":"/2025/07/08/d365-transferjournalandtransferorder/","content":"In Dynamics 365 Finance and Operations (D365 F&amp;O), knowing the difference between a transfer journal and a Transfer Order is crucial when handling inventories. Although they seem to be related, these two features serve separate purposes and meet different needs.\nThis write-up explores the nuances of transfer journals and transfer orders, explaining their differences and uses inside D365 F&amp;O.\nOverview of Dynamics 365 Finance and OperationsDesigned to maximize business processes, Dynamics 365 Finance and Operations is a complete enterprise resource planning (ERP) tool. Among its many capabilities are supply chain management, inventory control, and financial management. Within the field of inventory control, the correct and effective movement of products is mostly dependent on Transfer Journals and Transfer Orders.\nLet‚Äôs learn about them, one by one.\nWhat is a Transfer Journal?One simple tool for internal inventory movement in D365 Finance and Operations is a transfer journal. It lets organizations move goods between several sites inside the same warehouse or between closely spaced warehouses without including thorough tracking or shipping documents.\nTransfer journals are perfect for regular inventory changes and internal relocations because of their simplicity.\nScenarios for Transfer Journals:\nInternal Reorganization: Transfer Journals allow an organization to shift goods from one bin location to another inside the same warehouse when it needs to rearrange its warehouse layout. This simplifies the maintenance of an accurate record of inventory locations free from the complexity of shipping documentation.\nCorrecting Mistakes: A Transfer Journal allows one to rapidly rectify mistakes in items received with erroneous tracking numbers or at the wrong location. Businesses can keep exact traceability by moving goods between tracking dimensions, such as batch or serial numbers.\nClose Proximity Transfers: Transfer Journals help to streamline the process while goods are being moved between two geographically close warehouses. This simplifies the transfer procedure by removing the necessity for thorough tracking and documentation for delivery.\n\nHow to Create and Process a Transfer Journal?Creating and processing a Transfer Journal in D365 Finance and Operations involves a few straightforward steps:\n\nNavigate to Inventory Management &gt; Journal entries &gt; Items &gt; Transfer.\nCreate a new journal by clicking ‚ÄúNew‚Äù. Add the required information including the journal name, description, site, and warehouse.\nEnter the item number, quantity, from site, to site, from warehouse, and to warehouse to add the items you wish to transfer.\nValidate the journal to look for mistakes. Post the journal once validated to complete the transfer. This will change the levels of inventory in the designated sites.\nNavigate to Inventory management &gt; Inquiries and reports &gt; Journals &gt; Item transactions to review the transfer specifics. To read the specifics, choose the journal you posted and click ‚ÄúTransactions‚Äù.\nGet Dynamics 365 Finance and Operations implemented by a top Microsoft Gold partner in the USA‚ÄîDynamics Square. Schedule a free consultation now!\n\n\n\nWhat is a Transfer Order?A transfer order in D365 Finance and Operations is designed as a completed tool for moving stocks between warehouses or sites where thorough tracking and shipping paperwork are needed.\nTransfer orders are appropriate for circumstances whereby objects must be tracked throughout travel since they offer more control and visibility over the transfer process.\nScenarios for Transfer Orders:\nLong-Distance Transfers: Transfer Orders guarantee that goods are being traced all through the transportation process when goods are being moved between warehouses that are far apart. Maintaining inventory accuracy depends on tracking, shipping, and receiving documents, hence this covers all aspects.\nShipping Documentation: Transfer orders are utilized when shipment documentation is needed to go along with the items. This is crucial for giving customers comprehensive shipment data and following shipping laws.\nWarehouse Management Processes: Transfer Orders fit very well in settings where warehouse staff members handle picking, packing, shipping, and receiving items. They guarantee that every stage of the transfer process is recorded and tracked.\n\nHow to Create and Process a Transfer Order?Creating and processing a Transfer Order in D365 Finance and Operations involves several detailed steps:\n\nVisit Inventory Management &gt; Outbound orders &gt; Transfer Order to navigate.\nClick ‚ÄúNew‚Äù to draft a fresh transfer order. Now go into the ‚Äúfrom‚Äù and ‚Äúto‚Äù warehouses.\nEnter the item number and quantity to add the items you wish to move.\nGo to Inventory management &gt; Periodic &gt; Release transfer order picking. Click ‚ÄúOK,‚Äù then enter the transfer order number. Should the ‚ÄúDeduct released for picking‚Äù checkbox be chosen, the system will automatically deduct the pertinent quantity from the on-hand inventory.\nGo return to your transfer order and click ‚ÄúShip‚Äù in the Action Pane. Check the quantity and product; then, click ‚ÄúOK‚Äù to post the shipment.\nGo to Inventory management &gt; Inbound orders &gt; Transfer order. Choose the transfer order then click ‚ÄúReceive‚Äù on the Action Pane. Check the quantity and product; then, to finish the receipt, click ‚ÄúOK.‚Äù\n\nKey Differences Between Transfer Journals and Transfer OrdersComplexity and Application\nTransfer Journals: Simple and flexible, transfer journals fit for internal relocation, error correction, and close proximity transfers.\nTransfer Orders: These are more complicated, suited for long-distance transfers, needing shipping documents, and interacting with warehouse management systems.\n\nTracking and Documentation\nTransfer Journals: Minimal tracking and no need for shipping documentation. Ideal for internal transfers where detailed tracking is unnecessary.\nTransfer Orders: Detailed tracking with shipping and receiving documentation. Ensures visibility and control over the transfer process.\n\nInventory ImpactTransfer Journals: Inventory movements are recorded without offsetting costs. Suitable for internal adjustments and corrections.Transfer Orders: Inventory and its value are tracked throughout the transfer process, with potential impacts on costing methods like moving or weighted average.\n","categories":["d365"]},{"title":"How to Clone and Configure a D365FO Project From GitHub","url":"/2025/07/14/d365-cloneandconfigurd365fofromgithub/","content":"\nReprint from: https://alexdmeyer.com/2024/04/29/how-to-clone-and-configure-a-d365fo-project-from-github/\n\nFor reference only.\n","categories":["d365"],"tags":["git"]},{"title":"Document Routing Agent in D365 F&O","url":"/2025/07/08/d365-documentroutingconfiguration/","content":"\nReprinted from: https://mohitrampal.com/2023/03/20/document-routing-agent-in-d365-fo/\n\n\nYou can also watch video: https://www.youtube.com/watch?v=oG6n2PA-Phs\n\n\nChinese version: https://www.cnblogs.com/lingdanglfw/p/14141545.html\n\n\nOfficial documentation: https://learn.microsoft.com/en-us/dynamics365/fin-ops-core/dev-itpro/analytics/er-design-zpl-labels\n\n\nZPL View: https://labelary.com/viewer.html\n\nThe Document Routing Agent (DRA) is an application that resides on the Customer‚Äôs network, to act as a bridge between the internet-hosted Dynamics 365 (D365 F&amp;O) system and Customer‚Äôs network printers.\n\n\nDRA tool is Supported on Windows 8.1, Windows 10, Microsoft Windows Server 2012 R2, Microsoft Windows Server 2016, or Microsoft Windows Server 2019.\nDRA run as either a desktop application or a Microsoft Windows service.\nDRA as a Service can be configured to start automatically after a computer restart, so no user intervention is required. However, When the Document Routing Agent runs as a Windows service, document reports, such as checks, that require custom margins can‚Äôt be printed directly to network printers. Instead, the Document Routing Agent automatically routes those documents to a target folder.\nDRA as a desktop application uses Adobe Reader to spool the document to the shared printer device chosen in finance and operations. Microsoft recommends installing the Document Routing Agent in several places to manage situations when documents with custom margins need to be printed. The printers for those documents should thus only be installed on Document Routing Agents that will operate in desktop application mode. As an alternative, you can pick up the files in the target directory and guide them in the right direction using a post-execution process.\nSteps to Install &amp; Configure DRASign in to D365 F&amp;O environment which you want to configure in the DRA tool.\n\nGo to Organization Administration‚Äì&gt;Setup‚Äì&gt;Network Printers\nClick on Download Document Routing Agent Installer.\n\n\n\n\nEnsure that you are logged in as Admin user. Run the downloaded file and complete the setup.\nOpen the DRA tool and sign in with Admin account.\n\n\n\n\nClick on Settings Button and enter values in all the fields.\n\n\n\n\nIf Run as Windows Service checkbox is checked, then DRA will run as a Service. To run as service, window service should be set up and running.\n\nRight click on the highlighted Service and click on Properties.\n\n\nClick on Log On tab and add your Admin&#x2F;Service account.\n\n\nPlease note that step 6 is not required if running as an Application (Run as a window service checkbox is unchecked).\n\nStart the service and go back to step 5 and Click on Printers.\n\nOnly printers which are registered will be visible in D365 F&amp;O.\n\n\n\nAfter registering a printer, go to D365 F&amp;O (Organization Administration‚Äì&gt;Setup‚Äì&gt;Network Printers) and activate the printer.\n\n\n\n\nNow, you can test it in your reports by using Network Printer as shown below (after printing to screen), or setting up the print management.\n\n\n\nI had a requirement to test multiple network printers based on specific values, like if department is A the document should route to PrinterA, if department is B, it should go to PrinterB etc. This configuration was done in print management of report and I tested with dummy Printers and OneNote.\nYou can setup a dummy printer by going to Printers &amp; Scanners.\n\nClick on Add a Printer or Scanner button.\n\n\n\n\nClick on ‚ÄòThe printer that I want isn‚Äôt listed.‚Äô\n\n\n\n\nSelect last option as below screenshot and click Next.\n\n\n\n\nSelect Nul port and click Next.\n\n\n\n\nSelect Microsoft Print to PDF and click Next\n\n\n\n\n\n\nSpecify printer name and click Next.\n\n\n\n\n\n\nClick on Open Queue of Printer and Pause Printing.\n\n\n\n\nAs mentioned earlier, you need to register the printer.\n\n\n\n\nAfter registering the printer, it will be visible in D365 F&amp;O. Activate the printer.\n\n\n\n\n\n\nAs you can see, After report is printed on screen, I can select my new printer.\n\n\n\n\n\n\nThe document will be visible in print queue.\n\n\n\nNote\nDRA is legal entity specific, so you have to setup the printers in all required legal entities.\nIf you already have DRA tool, you might get below error for different versions.To resolve this, you have to uninstall the DRA and install again.\n\n","categories":["d365"]},{"title":"„ÄêHMT„ÄëHow to Install HMT Development Tools","url":"/2025/07/13/hmt-installtutorial/","content":"Installing Huamei 365¬Æ D365FO Tools for Visual StudioTo improve development efficiency in Dynamics 365 Finance and Operations (D365FO), the Huamei 365¬Æ D365FO Tools extension offers a suite of useful generators and helpers. This blog post provides a quick guide to installing this extension in Visual Studio 2022.\nüîß Step 1: Open the Extensions MenuIn Visual Studio 2022, go to the top menu and click Extensions.\n\n\n\nüîç Step 2: Browse ExtensionsIn the Extensions dropdown, select Manage Extensions. In the Extension Manager, go to the Browse tab and use the search bar to look for Huamei 365¬Æ D365FO Tools.\n\n\n\n\n\n\n\n‚úÖ Step 3: Locate and Install the ExtensionFind Huamei 365¬Æ D365FO Tools in the search results. Click Install on the right-hand panel.\n\n\n\nüìã Requirements\nVisual Studio 2022 version 17.13.+\nThe extension is designed specifically for D365FO development and may not work outside this context.\n\n\nüì¢ Feedback &amp; SupportFor feedback and bug reports, contact the author directly at:üìß Willie.You@huameisoft.cn\n\nBy using Huamei 365¬Æ D365FO Tools, you can significantly improve your productivity when working on D365FO projects. Be sure to keep your extension updated to enjoy new features and improvements.\n","categories":["x++"],"tags":["HMT"]},{"title":"The Way for Clearing the Log Disk","url":"/2024/12/23/mssql-clear-log/","content":"\n\nThe example SQL script code as shown below:\nuse [AxDB]SELECT name FROM sys.database_filesUSE [master]GOALTER DATABASE [AxDB] SET RECOVERY SIMPLE WITH NO_WAITGOUSE [AxDB]GODBCC SHRINKFILE (AxDB_Restore_log, 1024)GOUSE [master]GOALTER DATABASE [AxDB] SET RECOVERY FULL WITH NO_WAITGO","categories":["t-sql"]},{"title":"Implement the SysExtensionSerializer","url":"/2025/07/14/xpp-ImplementTheSysExtensionSerializer/","content":"You can add fields to a table by using an extension. If you‚Äôre adding more than 10 fields to a table extension, the compiler throws the best practice error. We recommend that you use the alternative way of creating a new table and adding a foreign key relation to the standard table. Maps are available to help you improve a developer‚Äôs processes. The SysExtensionSerializerMap and SysExtensionSerializerExtensionMap maps make the create, read, update, and delete (CRUD) operations automated to the custom table.You can create a new table for your new fields, as the following image depicts.\n\n\nConsider the following details about implementing the SysExtensionSerializer extensionÔºö\n\nThe CustTable field is an int64 (RecId).\nIt creates relation to the CustTable standard table and points to RecId on CustTable, as the following screenshot shows.\n\n\n\n\nIt creates mapping to map the SysExtensionSerializerExtensionMap field BaseRecId to a new table called MyCustTable and the CustTable field„ÄÇ\nIt creates an alternate key (Index) on the table for the CustTable field in the MyCustTable table. For the table property, the Replacement Key is set to the Alternate key, as the following screenshot shows.\n\n\n\nThe SysExtensionSerializerMap contains methods for automatically inserting, updating, and performing many other functions. The standard CustTable table includes calls to the SysExtensionSerializer framework, which means that whenever a record in CustTable is updated, your table is also updated, as the following screenshot shows.\n\n\nUsing the SysExtensionSerializer framework fields helps you add a related table by following best practices and enabling CRUD functionality.\n","categories":["x++"],"tags":["Table","Extend"]},{"title":"How to Copy the Add Items","url":"/2025/07/11/xpp-copyadditemsfeature/","content":"SummaryThe D365 F&amp;O has an out of box function named ‚ÄúAdd products‚Äú, If developer develops an item-base table and wants to copy this function for this table. The following codes.\nCode ExampleTo begin with, we need to extend the standard system class to implement a custom strategy for loading default items in the ‚ÄòAdd Productions‚Äô dialog. When the user selects one or multiple lines and clicks the ‚ÄòAdd Productions‚Äô button, the dialog should automatically prefill the item field(s) based on the selected records.\nSecondly, we need to use a Chain of Command (CoC) extension on the createProducts method to implement the logic for adding items to the custom table.\n/// &lt;summary&gt;/// Willie Yao - 07/07/2025/// &lt;/summary&gt;[ExtensionOf(classStr(RetailCreateLinesFromProductsToAdd))]final class HMClass_RetailCreateLinesFromProductsToAdd_Extension&#123;    /// &lt;summary&gt;    /// Willie Yao - 07/07/2025    /// loadLinesFromCaller    /// &lt;/summary&gt;    /// &lt;param name=&quot;_callerArgs&quot;&gt;&lt;Args/param&gt;    /// &lt;param name=&quot;_tmpProductsToAdd&quot;&gt;TmpRetailProductsToAdd&lt;/param&gt;    public void loadLinesFromCaller(Args _callerArgs, TmpRetailProductsToAdd _tmpProductsToAdd)    &#123;        next loadLinesFromCaller(_callerArgs, _tmpProductsToAdd);        TableId callerTableId = _callerArgs.dataset();        switch (callerTableId)        &#123;            case tableNum(HMTable):                this.loadHMTable();                break;        &#125;    &#125;    /// &lt;summary&gt;    /// Willie Yao - 07/07/2025    /// loadHMTable    /// &lt;/summary&gt;    internal void loadHMTable()    &#123;        InventTable     inventTable;        EcoResProduct   ecoResProduct;        HMTable         MTable = callerArgs.record();        select firstonly product from inventTable            where inventTable.ItemId == MTable.ItemId            join ecoResProduct                where ecoResProduct.RecId == inventTable.Product;        this.loadLines(ecoResProduct, 1, InventDim::findOrCreateBlank().inventDimId);    &#125;    /// &lt;summary&gt;    /// Willie Yao - 07/07/2025    /// createProducts    /// &lt;/summary&gt;    /// &lt;param name=&quot;_tmpProductsToAdd&quot;&gt;TmpRetailProductsToAdd&lt;/param&gt;        public void createProducts(TmpRetailProductsToAdd _tmpProductsToAdd)    &#123;        next createProducts(_tmpProductsToAdd);        switch (common.TableId)        &#123;            case tableNum(HMTable):                this.createHMTable(HMTable::findByRecId(common.RecId), _tmpProductsToAdd);                break;        &#125;    &#125;    /// &lt;summary&gt;    /// Willie Yao - 07/07/2025    /// createHMTable    /// &lt;/summary&gt;    /// &lt;param name=&quot;_HMTable&quot;&gt;HMTable&lt;/param&gt;    /// &lt;param name=&quot;_tmpProductsToAdd&quot;&gt;TmpRetailProductsToAdd&lt;/param&gt;    internal void createHMTable(HMTable _HMTable, TmpRetailProductsToAdd _tmpProductsToAdd)    &#123;        HMTable HMTable;        ttsbegin;        while select _tmpProductsToAdd        &#123;            HMTable.clear();            HMTable.ItemId = _tmpProductsToAdd.ItemId;            // Others customized fields value populated logic.            if (HMTable.validateWrite())            &#123;                HMTable.insert();            &#125;                    &#125;        ttscommit;    &#125;&#125;\n\nFinally, we need to override the createCallerTableRecords method in the RetailAddItems form to trigger the logic for creating item records.\n/// &lt;summary&gt;/// Willie Yao - 07/07/2025/// &lt;/summary&gt;[ExtensionOf(formStr(RetailAddItems))]final class HMForm_RetailAddItems_Extension&#123;    /// &lt;summary&gt;    /// Willie Yao - 07/07/2025    /// createCallerTableRecords    /// &lt;/summary&gt;    /// &lt;param name=&quot;_callerTableId&quot;&gt;TableId&lt;/param&gt;    /// &lt;param name=&quot;_tmpInventTable&quot;&gt;TmpRetailProductsToAdd&lt;/param&gt;    public void createCallerTableRecords(TableId _callerTableId, TmpRetailProductsToAdd _tmpInventTable)    &#123;        next createCallerTableRecords(_callerTableId, _tmpInventTable);        switch (_callerTableId)        &#123;            case tableNum(HMTable):                this.createOrderLine(FormDataUtil::getFormDataSource(this.args().record()));                break;        &#125;    &#125;&#125;"},{"title":"X++ api list","url":"/2024/12/23/xpp-api-list/","content":"FileIOPermissionFileIOPermissionÁ±ªÁî®‰∫éËÆæÁΩÆÊñá‰ª∂ÁöÑËÆøÈóÆÊùÉÈôê„ÄÇassert()ÊñπÊ≥ïÁî®‰∫éÈ™åËØÅFileIOPermissionÁ±ªËÆæÁΩÆÊùÉÈôêÊòØÂê¶ÊàêÂäüÔºåÂ¶ÇÊûúÈîôËØØÔºå‰æø‰ºöÊäõÂá∫ÈîôËØØÔºåÊïàÊûúÁ±ª‰ººtry catchÁ®ãÂ∫èÂùó„ÄÇ\nRecordInsertListÁî®‰∫éÊâπÈáèÊèíÂÖ•ÁöÑÂ∑•ÂÖ∑Á±ªÔºåÁ§∫‰æã‰ª£Á†ÅÂ¶Ç‰∏ãÔºö\n","categories":["x++"]},{"title":"Adding Barcode to a Report","url":"/2025/07/14/xpp-addbarcodetossrs/","content":"\nReprint from: https://d365ffo.com/2023/02/17/ax-d365fo-adding-barcode-to-a-report/comment-page-1/\n\n","categories":["x++"],"tags":["ssrs"]},{"title":"How To Create A D365 SSRS Report","url":"/2025/07/11/xpp-createanewssrsreport/","content":"\nReprint from: https://dynamics365musings.com/create-a-d365-ssrs-report/\n\nI think this blog article is very detailed.\n","categories":["x++"],"tags":["ssrs"]},{"title":"Create ledger journals in D365FO using X++","url":"/2025/07/09/xpp-createledgerjournals/","content":"\nReprinted from: https://denistrunin.com/xpptools-createledgerjournal/\n\nCreating LedgerJournalTrans using X++ is quite a common task, but sometimes I still see some mistakes(mostly related to fields initialization from account&#x2F;offset account and voucher assignment). In this post, I‚Äôll try to describe possible options how to create ledger journals in D365FO.\nTest scenarioTo test different methods, I wrote a Runnable class DEVTutorialCreateLedgerJournal that creates a new journal based on the data from the existing source journal using different methods. The dialog looks like this\n\n\nLet‚Äôs discuss possible copy options(Copy type parameter):\nLedgerJournalEngine classThis method is using LedgerJournalEngine class - the same class that is used when the user creates a journal manually on the Journal lines form. This increases the chances that the resulting line will be the same as a manually created line.\nwhile select ledgerJournalTransOrig    order by RecId            where ledgerJournalTransOrig.JournalNum == _ledgerJournalTableOrig.JournalNum&#123;    numLines++;    if (!ledgerJournalTable.RecId)    &#123;        //Often journal name from parameters is specified here        DEV::validateCursorField(ledgerJournalName, fieldNum(LedgerJournalName, JournalName));        ledgerJournalTable.clear();        ledgerJournalTable.initValue();        ledgerJournalTable.JournalName = ledgerJournalName.JournalName;        ledgerJournalTable.initFromLedgerJournalName();        ledgerJournalTable.JournalNum = JournalTableData::newTable(ledgerJournalTable).nextJournalId();        ledgerJournalTable.Name = strFmt(&quot;Copy of %1, Date %2&quot;, _ledgerJournalTableOrig.JournalNum, DEV::systemdateget());        ledgerJournalTable.insert();        info(strFmt(&quot;Journal %1 created&quot;, ledgerJournalTable.JournalNum));        ledgerJournalEngine = LedgerJournalEngine::construct(ledgerJournalTable.JournalType);        ledgerJournalEngine.newJournalActive(ledgerJournalTable);    &#125;    ledgerJournalTrans.clear();    ledgerJournalTrans.initValue();    ledgerJournalEngine.initValue(ledgerJournalTrans);    ledgerJournalTrans.JournalNum           =   ledgerJournalTable.JournalNum;    ledgerJournalTrans.TransDate            =   DEV::systemdateget();    ledgerJournalTrans.AccountType          =   ledgerJournalTransOrig.AccountType;    ledgerJournalTrans.modifiedField(fieldNum(LedgerJournalTrans, AccountType));    ledgerJournalTrans.LedgerDimension = ledgerJournalTransOrig.LedgerDimension;    if (!ledgerJournalTrans.LedgerDimension)    &#123;        throw error(&quot;Missing or invalid ledger dimension for journal process&quot;);    &#125;    ledgerJournalTrans.modifiedField(fieldNum(LedgerJournalTrans, LedgerDimension));    ledgerJournalEngine.accountModified(LedgerJournalTrans);    ledgerJournalTrans.OffsetAccountType = ledgerJournalTransOrig.OffsetAccountType;    ledgerJournalTrans.modifiedField(fieldNum(LedgerJournalTrans, OffsetAccountType));    ledgerJournalTrans.OffsetLedgerDimension = ledgerJournalTransOrig.OffsetLedgerDimension;    ledgerJournalTrans.modifiedField(fieldNum(LedgerJournalTrans, OffsetLedgerDimension));    ledgerJournalEngine.offsetAccountModified(ledgerJournalTrans);    //amounts    LedgerJournalTrans.CurrencyCode         =   ledgerJournalTransOrig.CurrencyCode;    ledgerJournalEngine.currencyModified(LedgerJournalTrans);    LedgerJournalTrans.AmountCurCredit      =   ledgerJournalTransOrig.AmountCurCredit;    LedgerJournalTrans.AmountCurDebit       =   ledgerJournalTransOrig.AmountCurDebit;    //additional fields    LedgerJournalTrans.Approver           = HcmWorker::userId2Worker(curuserid());    LedgerJournalTrans.Approved           = NoYes::Yes;    ledgerJournalTrans.Txt                = ledgerJournalTransOrig.Txt;    LedgerJournalTrans.SkipBlockedForManualEntryCheck = true;    DEV::validateWriteRecordCheck(ledgerJournalTrans);    ledgerJournalTrans.insert();    ledgerJournalEngine.write(ledgerJournalTrans);&#125;\n\nWhen you modify Account&#x2F;Offset account fields in this example you need to call two methods(on ledgerJournalTrans and ledgerJournalEngine). This ensures that the line will be properly initialized from the Account&#x2F;Offset account field.\nledgerJournalTrans.modifiedField(fieldNum(LedgerJournalTrans, LedgerDimension));  ledgerJournalEngine.accountModified(LedgerJournalTrans);\n\nVoucher assignment here is processing in ledgerJournalEngine.write().\nAlso, an interesting flag here is LedgerJournalTrans.SkipBlockedForManualEntryCheck. It is useful when you don‚Äôt want to allow users to create manually lines with the same accounts as in your procedure.\nLedgerJournalTrans defaultRow() methodThis is a new approach in D365FO and it uses a new defaultRow() table method. Data entities also call this method during the import process. Its idea is that we don‚Äôt control the sequence of different modifiedField method calls, we just populate the fields that we know, all other logic happens in the defaultRow() method.\nCode for journal creation in this case:\nwhile select ledgerJournalTransOrig    order by RecId    where ledgerJournalTransOrig.JournalNum == _ledgerJournalTableOrig.JournalNum&#123;    numLines++;    if (!ledgerJournalTable.RecId)    &#123;        ledgerJournalTable.clear();        ledgerJournalTable.initValue();        ledgerJournalTable.JournalName = _ledgerJournalTableOrig.JournalName;        ledgerJournalTable.initFromLedgerJournalName();        ledgerJournalTable.JournalNum = JournalTableData::newTable(ledgerJournalTable).nextJournalId();        ledgerJournalTable.Name = strFmt(&quot;Copy of %1, Date %2&quot;, _ledgerJournalTableOrig.JournalNum, DEV::systemdateget());        ledgerJournalTable.insert();        info(strFmt(&quot;Journal %1 created&quot;, ledgerJournalTable.JournalNum));    &#125;    ledgerJournalTrans.clear();    ledgerJournalTrans.initValue();    ledgerJournalTrans.JournalNum             = ledgerJournalTable.JournalNum;    ledgerJournalTrans.TransDate              = DEV::systemdateget();    ledgerJournalTrans.AccountType            = ledgerJournalTransOrig.AccountType;    ledgerJournalTrans.LedgerDimension        = ledgerJournalTransOrig.LedgerDimension;    ledgerJournalTrans.DefaultDimension       = ledgerJournalTransOrig.DefaultDimension;    ledgerJournalTrans.OffsetAccountType      = ledgerJournalTransOrig.OffsetAccountType;    ledgerJournalTrans.OffsetLedgerDimension  = ledgerJournalTransOrig.OffsetLedgerDimension;    ledgerJournalTrans.OffsetDefaultDimension = ledgerJournalTransOrig.OffsetDefaultDimension;    ledgerJournalTrans.CurrencyCode           =   ledgerJournalTransOrig.CurrencyCode;    ledgerJournalTrans.AmountCurCredit        =   ledgerJournalTransOrig.AmountCurCredit;    ledgerJournalTrans.AmountCurDebit         =   ledgerJournalTransOrig.AmountCurDebit;    //addition fields    ledgerJournalTrans.Approver           = HcmWorker::userId2Worker(curuserid());    ledgerJournalTrans.Approved           = NoYes::Yes;    ledgerJournalTrans.Txt                = ledgerJournalTransOrig.Txt;    ledgerJournalTrans.SkipBlockedForManualEntryCheck = true;    ledgerJournalTrans.defaultRow();    DEV::validateWriteRecordCheck(ledgerJournalTrans);    ledgerJournalTrans.insert();&#125;\n\nYou can find an example of this approach in the MCRLedgerJournal class (and the usage is here)\nData entityWe can also use a data entity for journal creation. Technically it produces the same result as the previous method because a data entity at the end will call a table defaultRow() method.\nwhile select ledgerJournalTransOrig    order by RecId    where ledgerJournalTransOrig.JournalNum == _ledgerJournalTableOrig.JournalNum&#123;    numLines++;    select dimensionCombinationEntity        where dimensionCombinationEntity.RecId == ledgerJournalTransOrig.LedgerDimension;    select dimensionCombinationEntityOffset        where dimensionCombinationEntityOffset.RecId == ledgerJournalTransOrig.OffsetLedgerDimension;    ledgerJournalEntity.initValue();    ledgerJournalEntity.JournalBatchNumber     = journalNum;    ledgerJournalEntity.Description            = strFmt(&quot;Copy of %1, Date %2&quot;, _ledgerJournalTableOrig.JournalNum, DEV::systemdateget());    ledgerJournalEntity.JournalName            = _ledgerJournalTableOrig.JournalName;    ledgerJournalEntity.LineNumber++;    //if you have string and want to convert to ID - DimensionDefaultResolver::newResolver(_dimensionDisplayValue).resolve();    //AX &gt; General ledge &gt; Chart of accounts &gt; Dimensions &gt; Financial dimension configuration for integrating applications    ledgerJournalEntity.AccountType                 = ledgerJournalTransOrig.AccountType;    ledgerJournalEntity.AccountDisplayValue         = dimensionCombinationEntity.DisplayValue;    ledgerJournalEntity.OffsetAccountType           = ledgerJournalTransOrig.OffsetAccountType;    ledgerJournalEntity.OffsetAccountDisplayValue   = dimensionCombinationEntityOffset.DisplayValue;    ledgerJournalEntity.CreditAmount                = ledgerJournalTransOrig.AmountCurCredit;    ledgerJournalEntity.DebitAmount                 = ledgerJournalTransOrig.AmountCurDebit;    ledgerJournalEntity.CurrencyCode                = ledgerJournalTransOrig.CurrencyCode;    ledgerJournalEntity.TEXT                        = ledgerJournalTransOrig.Txt;    ledgerJournalEntity.TRANSDATE                   = ledgerJournalTransOrig.TransDate;    ledgerJournalEntity.defaultRow();    DEV::validateWriteRecordCheck(ledgerJournalEntity);    ledgerJournalEntity.insert();    journalNum = ledgerJournalEntity.JournalBatchNumber;&#125;\n\nAs you see this method requires less code: we don‚Äôt even need to write code for the journal header creation, it is all handled by the data entity insert() method. Dimensions can be also specified as strings. However there are some limitations: sometimes data entity doesn‚Äôt contain all the table fields and it doesn‚Äôt support all account types.\nPerformance testingLet‚Äôs test the performance. First I created a test journal with the 1000 lines(createByCombination method) and then copied it using these 3 different methods. I got the following results:\n\n\n\nMethod\nTime to create 1000 lines(sec)\n\n\n\nUsing ledgerJournalEngine\n30.54\n\n\nUsing DataEntity\n33.09\n\n\nUsing Table defaultRow method\n15.18\n\n\nThere are some differences between the copy speed in my example, but it is caused by a different logic for the dimension creation, so the result is that all methods are almost equal and quite fast. In a real-life scenario, you can expect an insert speed 10-30 lines per second.\nChoosing the right method and things to avoidIn general, you have 2 options - to create a journal similar to the manual user entry or create it similar to the import procedure(for the second scenario choice between entity and table mostly depends on what input data you have and whether the entity supports all the required fields). So the choice between these two should be made by answering the question: if the user wants to create the same journal manually, does he use manual entry or data import? Use createJournalUsingLedgerJournalEngine as default, as it is more flexible.\nProbably in D365FO it is better to avoid creation using JournalTransData classes or when you simply populate ledgerJournalTrans fields and call insert(). This initially can work, but later users may complain - e.g. ‚ÄúWhy when I create a journal manually and specify a vendor account the Due date field is calculated, but your procedure doesn‚Äôt fill it‚Äú.\nSummaryYou can download this class using the following link createJournalUsingLedgerJournalEngine. The idea is that you can use this code as a template when you have a task to create(or post) a ledger journal using X++. Comments are welcome.\n","categories":["x++"],"tags":["LedgerJournalTrans"]},{"title":"Dynamics 365 Debugging Configuration","url":"/2025/02/23/xpp-debug-configuration/","content":"\nÂΩìÊó†Ê≥ï debug Á≥ªÁªüÊ†áÂáÜÁöÑ‰ª£Á†ÅÊó∂ÔºåÂèØ‰ª•ÊåâÁÖßÊú¨ÊñáÁöÑÊ≠•È™§ÈÖçÁΩÆ\n\nÂØºËà™ Tools &gt; OptionsÔºåÂú® Dynamics 365 &gt; Debugging tab È°µÈù¢ÈÖçÁΩÆ debug Áõ∏ÂÖ≥Â±ûÊÄßÔºåÂ¶Ç‰∏ãÂõæÔºåÂú® Included Packages ‰∏≠ÈÄâÊã©ÔºåÂú® debug ‰∏≠ÈúÄË¶Å load ÁöÑ model„ÄÇ\n","categories":["x++"]},{"title":"Extend CustTrans and VendTrans","url":"/2025/07/09/xpp-extendedvendtransandcusttrans/","content":"\nJust recorded how to extend the feature regards the CustTrans and VendTrans.\n\nBring the customized fields of LedgerJournalTrans to CustTrans or VendTransIf the requirement wants to create the new fields on CustTrans&#x2F;VendTrans and LedgerJournalTrans, and want to sync the customized fields to Transaction record after posting the customer journal or vendor journal. You can extend the CustVoucherJournal&#x2F;VendVoucherJournal as follows:\n/// &lt;summary&gt;/// Willie Yao - 07/08/2025/// &lt;/summary&gt;[ExtensionOf(classstr(CustVoucherJournal))]final class HMClass_CustVoucherJournal_Extension&#123;    /// &lt;summary&gt;    /// Willie Yao - 07/08/2025    /// &lt;/summary&gt;    /// &lt;param name = &quot;custVendTrans&quot;&gt;CustVendTrans&lt;/param&gt;    /// &lt;param name = &quot;_ledgerPostingJournal&quot;&gt;LedgerVoucher&lt;/param&gt;    /// &lt;param name = &quot;_useSubLedger&quot;&gt;UseSubLedger&lt;/param&gt;    protected void initCustVendTrans(        CustVendTrans   custVendTrans,         LedgerVoucher   _ledgerPostingJournal,         boolean         _useSubLedger)    &#123;        next initCustVendTrans(custVendTrans, _ledgerPostingJournal, _useSubLedger);                LedgerJournalTrans ledgerJournalTrans;        if (common.TableId == tablenum(LedgerJournalTrans))        &#123;            ledgerJournalTrans = common;            if (custVendTrans.TableId == tableNum(CustTrans))            &#123;                CustTrans custTrans  = custVendTrans;                custTrans.HMField1   = ledgerJournalTrans.HMField1;                custTrans.HMField2   = ledgerJournalTrans.HMField2;                custVendTrans        = custTrans;            &#125;        &#125;    &#125;&#125;/// &lt;summary&gt;/// Willie Yao - 07/08/2025/// &lt;/summary&gt;[ExtensionOf(classstr(VendVoucherJournal))]final class HMClass_VendVoucherJournal_Extension&#123;    /// &lt;summary&gt;    /// Willie Yao - 07/08/2025    /// &lt;/summary&gt;    /// &lt;param name = &quot;custVendTrans&quot;&gt;CustVendTrans&lt;/param&gt;    /// &lt;param name = &quot;_ledgerPostingJournal&quot;&gt;LedgerVoucher&lt;/param&gt;    /// &lt;param name = &quot;_useSubLedger&quot;&gt;UseSubLedger&lt;/param&gt;    protected void initCustVendTrans(        CustVendTrans   custVendTrans,         LedgerVoucher   _ledgerPostingJournal,         boolean         _useSubLedger)    &#123;        next initCustVendTrans(custVendTrans, _ledgerPostingJournal, _useSubLedger);        LedgerJournalTrans ledgerJournalTrans;        if (common.TableId == tablenum(LedgerJournalTrans))        &#123;            ledgerJournalTrans = common;            if (custVendTrans.TableId == tableNum(VendTrans))            &#123;                VendTrans vendTrans  = custVendTrans;                vendTrans.HMField1   = ledgerJournalTrans.HMField1;                custVendTrans        = vendTrans;            &#125;        &#125;    &#125;&#125;\n\nAdd new validation logic when posted LedgerJournalTransPlease coc the validation logic of LedgerJournalCheckPost class if developer wants to add new validation logic for LedgerJournalTrans post operation.\n/// &lt;summary&gt;/// Willie Yao - 07/08/2025/// &lt;/summary&gt;[ExtensionOf(classstr(LedgerJournalCheckPost))]final class HMClass_LedgerJournalCheckPost_Extension&#123;    /// &lt;summary&gt;    /// Willie Yao - 07/08/2025    /// &lt;/summary&gt;    /// &lt;param name = &quot;_calledFrom&quot;&gt;CalledFrom&lt;/param&gt;    /// &lt;returns&gt;True if validate right&lt;/returns&gt;    public boolean validate(Object _calledFrom)    &#123;        boolean ret = next validate(_calledFrom);        ret = this.newValidation() &amp;&amp; ret;        return ret;    &#125;    /// &lt;summary&gt;    /// Willie Yao - 07/08/2025    /// &lt;/summary&gt;    /// &lt;returns&gt;True if validate right&lt;/returns&gt;    internal boolean newValidation()    &#123;        LedgerJournalTrans  ledgerJournalTrans;        boolean             ok = true;        ok = this.newValidationLogic(ledgerJournalTrans) &amp;&amp; ok;        return ok;        &#125;&#125;\n\nExtend CustTrans&#x2F;VendTrans Reversal LogicDevelopers must coc the reversal method and write the customized logic after the next invoke method.\n/// &lt;summary&gt;/// Willie Yao - 07/08/2025/// &lt;/summary&gt;[ExtensionOf(classstr(TransactionReversal_Cust))]final class HMClass_TransactionReversal_Cust_Extension&#123;     /// &lt;summary&gt;    /// Willie Yao - 07/08/2025    /// &lt;/summary&gt;    /// &lt;param name = &quot;args&quot;&gt;Args&lt;/param&gt;    void reversal(Args args)    &#123;        next reversal(args);        // New Logic    &#125;    &#125;/// &lt;summary&gt;/// Willie Yao - 07/08/2025/// &lt;/summary&gt;[ExtensionOf(classstr(TransactionReversal_Vend))]final class HMClass_TransactionReversal_Vend_Extension&#123;    /// &lt;summary&gt;    /// Willie Yao - 07/08/2025    /// &lt;/summary&gt;    /// &lt;param name = &quot;args&quot;&gt;Args&lt;/param&gt;    void reversal(Args args)    &#123;        next reversal(args);        // New Logic    &#125;  &#125;\n\n\nMore expansion points will be updated successively in the future\n\n","categories":["x++"],"tags":["LedgerJournalTrans","CustTrans","VendTrans","Reversal"]},{"title":"RunBase How to Preventing Cache Retention in BatchJob Executions","url":"/2026/01/11/xpp-dontsavebatchjobcache/","content":"When developing a BatchJob in Dynamics 365 Finance and Operations, you might encounter an issue where the system retains cached data after a job runs. This results in incorrect data being used during subsequent runs, even after clearing the cache. This typically happens when global variables are initialized using args passed from the main method before calling the prompt method.\nThe Issue\nFirst Run: Cache is cleared, and the job runs correctly.\nSecond Run: The job uses cached data from the previous run, even after clearing the cache, because global variables were initialized before the prompt method.\n\nThis occurs because by default, the system retains the last execution state for future use.\nSolutionTo prevent the system from saving the last execution state, you can override the following method in the RunBaseBatch class:\npublic boolean allowSaveLast()&#123;    return false;&#125;\n\nBy returning false, you instruct the system not to save the data from the previous execution, ensuring that every run of the BatchJob starts fresh.\nWhy It WorksThe allowSaveLast() method is a hook in the RunBaseBatch class that determines whether or not the system saves the execution state after a BatchJob finishes. By overriding this method and returning false, you stop the system from storing the last job‚Äôs state, which can lead to the caching issue mentioned above.\nAdditional Steps: When Changes Don‚Äôt Take Effect ImmediatelyIn some cases, after making the above changes, the system might not immediately reflect the new settings. To ensure the changes are applied correctly, follow these additional steps:\n\nClear the D365 Usage Data: This can help clear any old data that might still be cached.\nRestart IIS: After clearing the usage data, restart the IIS (Internet Information Services) service to refresh the system environment.\nRebuild the Project: Finally, rebuild the project to ensure all changes are compiled and active in the environment.\n\nThese steps are sometimes necessary when changes do not take effect immediately, ensuring the system is completely refreshed.\nConclusionTo resolve issues with leftover data from previous BatchJob executions, simply override the allowSaveLast() method and return false. If changes don‚Äôt take effect immediately, clear the D365 usage data, restart IIS, and rebuild the project to ensure everything runs as expected. This ensures that each run starts with fresh data, avoiding any problems related to cached or stale information.\n\nThis approach effectively controls the caching behavior and ensures consistent, accurate execution of your BatchJobs.\n","categories":["x++"],"tags":["RunBase"]},{"title":"How to create a new design for a Sales Invoice report in D365FO","url":"/2025/07/09/xpp-extendsalesinvoicereport/","content":"\nReprinted from: https://denistrunin.com/xpptools-createledgerjournal/\n\nCreating a new Sales Invoice report design using SSRS and X++ is quite a common task. In this post, I‚Äôll try to describe how you can do this in Dynamics 365 Finance and Operations.\nSales Invoice report developmentI will use ‚ÄúDEVTutorial‚Äù prefix for new elements\nData provided classLet‚Äôs start with a data provider. We should create a new class and extend it from the standard SalesInvoiceDP. In this case, we can add additional fields that are relevant only for our report.\n[SRSReportParameterAttribute(classStr(SalesInvoiceContract))]class DEVTutorialSalesInvoiceDP  extends SalesInvoiceDP&#123;    protected void populateSalesInvoiceTmp(CustInvoiceJour _custInvoiceJour,            CustInvoiceTrans _custInvoiceTrans,            TaxSpec _taxSpec,            CustPaymSchedLine _custPaymSchedLine,            CustTrans _prepaymentCustTrans,            TaxTrans _prepaymentTaxTrans)    &#123;        super(_custInvoiceJour, _custInvoiceTrans, _taxSpec, _custPaymSchedLine, _prepaymentCustTrans, _prepaymentTaxTrans);        //populate additional fields in salesInvoiceTmp here        //salesInvoiceTmp.MyField = &#x27;&#x27;;        //this method is called for main lines and also for all linked tables        //please note, that it will not be called if there are already some data exist in salesInvoiceTmp table for the selected Sales order, you need to delete existing records       &#125;    protected void populateSalesInvoiceHeaderFooterTmp(CustInvoiceJour _custInvoiceJour, CompanyInfo _companyInfo)    &#123;        super(_custInvoiceJour, _companyInfo);        //populate additional fields in salesInvoiceTmp here        //salesInvoiceHeaderFooterTmp.MyField = &#x27;&#x27;;    &#125; &#125;\n\nReport designThen add a new SSRS report to our project\n\n\nWe need to add Datasets for this report. In the standard system we have 4 sales invoice datasets, let‚Äôs add them all.\n\n\n\nDataset name\nQuery\n\n\n\nSalesInvoiceDS\nSELECT * FROM DEVTutorialSalesInvoiceDP.SalesInvoiceTmp\n\n\nSalesInvoiceHeaderFooterDS\nSELECT * FROM DEVTutorialSalesInvoiceDP.SalesInvoiceHeaderFooterTmp\n\n\nSalesInvoiceLocalizationDS\nSELECT * FROM DEVTutorialSalesInvoiceDP.SalesInvoiceLocalizationTmp\n\n\nDocuBrandDetailsDS\nSELECT * FROM DEVTutorialSalesInvoiceDP.SysDocuBrandDetailsRegular\n\n\nAt the end you should have something like that:\n\n\nReport DesignThen let‚Äôs add a new Precision Design(Report)\nModify its properties: Size to standard A4 210x297mm and all Margins to 0.\n\n\nAdd the following sections\nHeader sectionFor the header, let‚Äôs add a logo from Document branding\n=First(Fields!Image1.Value, &quot;DocuBrandDetailsDS&quot;)\n\nand some client information\n=First(Fields!SalesId.Value, &quot;SalesInvoiceHeaderFooterDS&quot;)   &amp; vbcrlf &amp;  First(Fields!InvoiceDate.Value, &quot;SalesInvoiceHeaderFooterDS&quot;)  &amp; vbcrlf &amp;First(Fields!InvoicingAddress.Value, &quot;SalesInvoiceHeaderFooterDS&quot;)\n\nLine sectionAdd a new Tablix control with SalesInvoiceDS dataset\n\n\nAdjust Row visibility to the following formula ‚Äú&#x3D;IIF(Fields!ItemId.Value &#x3D; ‚Äú‚Äù, true, false)‚Äù as SalesInvoiceDS may contain data from linked tables(like payment schedule)\n\n\nLet‚Äôs also add a totals section. The resulting design should look like this.\n\n\nConnect a new report to Print managementA sales invoice can be used in a Print management module. In order to connect our report to this module, we need to subscribe to two events(create 2 new classes):\nUpdate 25&#x2F;11&#x2F;2021. A more detailed description can be found in the following blog How to Add New Report Format to Print Management\n[ExtensionOf(classstr(PrintMgmtReportFormatPopulator))]final class PrintMgmtReportFormatPopulatorDEVTutorial_Extension&#123;   protected void addDocuments()    &#123;        this.addStandard(PrintMgmtDocumentType::SalesOrderInvoice);        next addDocuments();    &#125; &#125;final static class PrintMgmtDocTypeDEVTutorial_EventHandler&#123;     [SubscribesTo(classstr(PrintMgmtDocType), delegatestr(PrintMgmtDocType, getDefaultReportFormatDelegate))]    public static void getDefaultReportFormatDelegate(PrintMgmtDocumentType _docType, EventHandlerResult _result)    &#123;   switch (_docType)        &#123;            case PrintMgmtDocumentType::SalesOrderInvoice:                _result.result(ssrsReportStr(DEVTutorialSalesInvoice, Report));                break;        &#125;  &#125; &#125;\n\nTest Sales invoice reportThat is all. It is time to test our report.\nBuild and deploy the report. Then, before the test, you need to add it to the print management settings. In order to do this - run the following job\nclass DEVTutorialPopulateReports&#123;   public static void main(Args _args)    &#123;        PrintMgmtReportFormatPopulator::construct().populate();    &#125;&#125;\n\nNext step is to add a logo to our report. Go to the Document images form and upload the image. Then go to the Branding details form and select this image.\nTo print the invoice go to the Accounts receivable - Invoice journal, select Document - Original preview and you should see our sample report:\n\n\nThe future of SSRS reportingThere may be a question of what is the future of SSRS reporting. Considering the latest news, I think that its popularity may grow. Microsoft recently released Power BI Paginated Reports that are completely based on SSRS ‚Äúrdl‚Äù files. Technically a new Power BI Paginated Reports Builder is an old SSRS report builder with a new name(yes, another name change).\nCheck, for example, this recent course Power BI Paginated Reports in a Day course. Almost all its modules(except maybe 04) are relevant to D365FO development.\nAnd this Bear in the previous picture is not just a funny picture, it is an official mascot of Power BI Paginated Reports. So with a new name and a new Bear, I hope the popularity of SSRS may grow.\nSSRS reporting issuesIf you watch this ‚ÄúPower BI Paginated reports Day course‚Äú you may feel that SSRS is cool(presentation is really great). However, the last main update for Report Builder was 10 years ago and the current version has some issues. Just some of them:\n\n‚Äúrdl‚Äù file is a very complex XML format. So in most cases, you will not be able to compare changes in the report - by using text compare you will see a huge number of differences in XML structure even for a small design change.\nPage splitting is very basic. For example, if you have a data row that consists of multiple lines and you want to avoid page breaks inside this row, you may find that this is not supported and you need to develop your own page grouping solution.\nYou can‚Äôt define a section that prints something on the footer of the last report page(and it is a quite popular requirement for reports - often it contains some bank payment information). There is a workaround for this if your report has 1 or 2 pages - you can put this information on page footer and hide the element using Globals!PageNumber and Globals!TotalPages variables, but if a report has 3 or more pages this will leave an empty space on these pages.\nReport designer doesn‚Äôt support formulas for defining Width property.So there are a lot of things that can be improved, and I hope Microsoft will invest in it.\n\nSummaryReal-life invoice reports can be quite complex and require a lot of efforts to create them. However, as we see, creating a simple Sales Invoice design is not a complex task. You can use the project above as a starting point(another option to consider is to install modern design templates).\nIf you have some hints for SSRS report development, don‚Äôt hesitate to post a comment. The project used in this post can be downloaded from my GitHub(you can download a model to a temporary folder and add elements from it to your project using ‚ÄúAdd - Existing item..‚Äù command)\n","categories":["x++"],"tags":["ssrs","sales invoice report"]},{"title":"How to bring the sub billing schedule customized field value to sales order","url":"/2025/07/11/xpp-extendsubbillingschedule/","content":"Developer can extend SubBillCreateSalesOrder class to extend the customized fields value populated logic. Please see the example code:\n/// &lt;summary&gt;/// Willie Yao - 07/04/2025/// The extension class for SubBillCreateSalesOrder/// &lt;/summary&gt;[ExtensionOf(classStr(SubBillCreateSalesOrder))]final class HMClass_SubBillCreateSalesOrder_Extension&#123;    /// &lt;summary&gt;    /// Willie Yao - 07/04/2025    /// Coc the &lt;c&gt;createSalesLine&lt;/c&gt; method for initialing the sales line&#x27;s customized fields.    /// &lt;/summary&gt;    /// &lt;param name=&quot;_salesLine&quot;&gt;SalesLine&lt;/param&gt;    /// &lt;param name=&quot;_salesLineConsolidated&quot;&gt;SubBillSalesLineConsolidated&lt;/param&gt;    /// &lt;param name=&quot;_salesIdCon&quot;&gt;_salesIdCon&lt;SalesId/param&gt;    /// &lt;param name=&quot;_allocEnabled&quot;&gt;AllocEnabled&lt;/param&gt;    /// &lt;param name=&quot;_splitByItemGroup&quot;&gt;SplitByItemGroup&lt;/param&gt;    /// &lt;param name=&quot;_isInvoiceCreator&quot;&gt;IsInvoiceCreator&lt;/param&gt;    /// &lt;param name=&quot;_includeBillingDatesToItem&quot;&gt;IncludeBillingDatesToItem&lt;/param&gt;    /// &lt;returns&gt;SalesLine&lt;/returns&gt;    public static SalesLine createSalesLine(        SalesLine _salesLine,        SubBillSalesLineConsolidated _salesLineConsolidated,        SalesId _salesIdCon,        boolean _allocEnabled,        boolean _splitByItemGroup,        boolean _isInvoiceCreator,        boolean _includeBillingDatesToItem)    &#123;        SubBillScheduleLine     scheduleLine    = SubBillScheduleLine::find(_salesLineConsolidated.SubBillBillingScheduleNumber, _salesLineConsolidated.LineNum);        SubBillScheduleTable    scheduleTable   = SubBillScheduleTable::find(_salesLineConsolidated.SubBillBillingScheduleNumber);        SalesLine               salesLine       = next createSalesLine(_salesLine, _salesLineConsolidated, _salesIdCon, _allocEnabled, _splitByItemGroup, _isInvoiceCreator, _includeBillingDatesToItem);                if (scheduleLine)        &#123;            salesLine.HMField1 = scheduleLine.HMField1;            salesLine.HMField2 = scheduleLine.HMField2;        &#125;        return salesLine;    &#125;    /// &lt;summary&gt;    /// Willie Yao - 07/04/2025    /// Coc the initSalesTable method    /// &lt;/summary&gt;    /// &lt;param name=&quot;_salesTable&quot;&gt;SalesTable&lt;/param&gt;    /// &lt;param name=&quot;_isInvoiceCreator&quot;&gt;IsInvoiceCreator&lt;/param&gt;    /// &lt;param name=&quot;_numberSeq&quot;&gt;NumberSeq&lt;/param&gt;    /// &lt;param name=&quot;_salesLineConsolidated&quot;&gt;SalesLineConsolidated&lt;/param&gt;    /// &lt;param name=&quot;_curParmId&quot;&gt;CurParmId&lt;/param&gt;    /// &lt;returns&gt;SalesTable&lt;/returns&gt;    public static SalesTable initSalesTable(        SalesTable _salesTable,        boolean _isInvoiceCreator,        NumberSeq _numberSeq,        SubBillSalesLineConsolidated _salesLineConsolidated,        ParmId _curParmId)    &#123;        SubBillScheduleTable    scheduleTable   = SubBillScheduleTable::find(_salesLineConsolidated.SubBillBillingScheduleNumber);        SalesTable              salesTable      = next initSalesTable(_salesTable, _isInvoiceCreator, _numberSeq, _salesLineConsolidated, _curParmId);        if (scheduleTable)        &#123;            salesTable.HMField1 = scheduleTable.HMField1;            salesTable.HMField2 = scheduleTable.HMField2;        &#125;        return salesTable;        &#125;    /// &lt;summary&gt;    /// Willie Yao - 07/04/2025    /// Coc the createSalesOrder method    /// &lt;/summary&gt;    /// &lt;param name=&quot;_createSalesHeader&quot;&gt;CreateSalesHeader&lt;/param&gt;    /// &lt;param name=&quot;_salesId&quot;&gt;SalesId&lt;/param&gt;    /// &lt;param name=&quot;salesLineConsolidated&quot;&gt;SubBillSalesLineConsolidated&lt;/param&gt;    /// &lt;param name=&quot;_consolidateByCustomer&quot;&gt;ConsolidateByCustomer&lt;/param&gt;    /// &lt;param name=&quot;_splitByItemGroup&quot;&gt;SplitByItemGroup&lt;/param&gt;    /// &lt;param name=&quot;_returnValues&quot;&gt;ReturnValues&lt;/param&gt;    /// &lt;param name=&quot;_includeBillingDatesToItem&quot;&gt;IncludeBillingDatesToItem&lt;/param&gt;    /// &lt;param name=&quot;_isInvoiceCreator&quot;&gt;IsInvoiceCreator&lt;/param&gt;    /// &lt;param name=&quot;_creditAdjMethod&quot;&gt;CreditAdjMethod&lt;/param&gt;    /// &lt;param name=&quot;_terminationDate&quot;&gt;TerminationDate&lt;/param&gt;    /// &lt;param name=&quot;_prorateDaily&quot;&gt;ProrateDaily&lt;/param&gt;    /// &lt;param name=&quot;_curParmId&quot;&gt;CurParmId&lt;/param&gt;    /// &lt;param name=&quot;_consolidateAllPeriods&quot;&gt;ConsolidateAllPeriods&lt;/param&gt;    /// &lt;returns&gt;container&lt;/returns&gt;    public static container createSalesOrder(        boolean _createSalesHeader,        SalesId _salesId,        SubBillSalesLineConsolidated salesLineConsolidated,        boolean _consolidateByCustomer,        boolean _splitByItemGroup,        container _returnValues,        boolean _includeBillingDatesToItem,        boolean _isInvoiceCreator,        SubBillCreditDeferralAdjMethod _creditAdjMethod,        SubBillTerminationDate _terminationDate,        boolean _prorateDaily,        ParmId _curParmId,        boolean _consolidateAllPeriods)    &#123;        SubBillScheduleTable scheduleTable = SubBillScheduleTable::find(salesLineConsolidated.SubBillBillingScheduleNumber);        if(!_createSalesHeader)        &#123;                        SalesTable salesTableForUpt;            ttsbegin;            update_recordset salesTableForUpt                setting HMField1 = scheduleTable.HMField1,                        HMField2 = scheduleTable.HMField2                where salesTableForUpt.SalesId == _salesId;            ttscommit;        &#125;        container newReturnContainer = next createSalesOrder(_createSalesHeader, _salesId, salesLineConsolidated, _consolidateByCustomer, _splitByItemGroup, _returnValues, _includeBillingDatesToItem, _isInvoiceCreator,_creditAdjMethod, _terminationDate, _prorateDaily, _curParmId, _consolidateAllPeriods);                return newReturnContainer;    &#125;&#125;","categories":["x++"],"tags":["Extend","SalesTable","SubBillingSchedule","SubBillingScheduleLine","SalesLine"]},{"title":"Get selected records in a grid on a form - X++","url":"/2025/07/08/xpp-getselectedrecords/","content":"If you can get the form data source element, then you can get the selected records. Developers usually can get the args in the source code. That is a sally port for extracting the selected records.\n\npublic static void main(Args _args)\n&#123;\n    FormRun formRun = _args.caller();\n    FormDataSource formDS = formRun.dataSource();\n    SalesTable salesTable; // Use the SalesTable for testing.\n\n    while (salesTable = formDS.mark(1) ? formDS.cursor() : formDS.getFirst(1);\n            salesTable:\n            salesTable.getNext())\n    &#123;&#125;\n&#125;\n\npublic void modified()\n&#123;\n    SalesTable salesTable; // Use the SalesTable for testing.\n\n    while (salesTable = SalesTable_ds.mark(1) ? SalesTable_ds.cursor() : SalesTable_ds.getFirst(1);\n            salesTable:\n            salesTable.getNext())\n    &#123;&#125;\n&#125;\n\n¬∑¬∑¬∑\n\n","categories":["x++"]},{"title":"Insert a Yes/No Message box on a Form Click Button event","url":"/2025/07/11/xpp-noyesdialog/","content":"\nReprint from: AX &#x2F; D365FO ‚Äì Insert a Yes&#x2F;No Message box on a Form Click Button event\n\nWhile any operation is performed by the user, there are cases such as need to receive confirmation from the user to perform the operation. In these cases we can use ‚ÄúDialogButton‚Äù for user interaction not say ‚ÄúYes&#x2F;No‚Äù to perform the operation.\nBelow is an example code:\npublic void clicked()&#123;   DialogButton diagBut;     str strMessage = &#x27;By clicking OK you confirm to save data into form, do you still want to continue?&#x27;;   str strTitle = &#x27;My Title&#x27;;   diagBut = Box::yesNo(strMessage, DialogButton::No, strTitle);   if (diagBut == DialogButton::No)   &#123;        info(&#x27;Operation canceled&#x27;);   &#125;   else if(diagBut == DialogButton::Yes)   &#123;          Info(&#x27;button click code here&#x27;);   &#125;&#125;","categories":["x++"],"tags":["Dialog"]},{"title":"Merge the Ledger Account","url":"/2024/12/23/xpp-merge-ledger-account/","content":"The example code as shown below:\npublic static LedgerDimensionAccount generateDefaultDimension(container _conName, container _conValue)&#123;    DimensionAttributeValueSetStorage   valueSetStorage = new DimensionAttributeValueSetStorage();    int                                 i;    DimensionAttribute                  dimensionAttribute;    DimensionAttributeValue             dimensionAttributeValue;    container                           conAttr  = _conName;    container                           conValue = _conValue;    str                                 dimValue;    for (i = 1; i &lt;= conLen(conAttr); i++)    &#123;        dimensionAttribute = dimensionAttribute::findByName(conPeek(conAttr,i));        if (dimensionAttribute.RecId == 0)        &#123;            continue;        &#125;        dimValue = conPeek(conValue,i);        if (dimValue != &quot;&quot;)        &#123;            // The last parameter is &quot;true&quot;. A dimensionAttributeValue record will be created if not found.            dimensionAttributeValue = dimensionAttributeValue::findByDimensionAttributeAndValue(dimensionAttribute, dimValue, false, true);            // Add the dimensionAttibuteValue to the default dimension            valueSetStorage.addItem(dimensionAttributeValue);        &#125;    &#125;    return valueSetStorage.save();&#125;public static LedgerDimensionAccount replaceDefaultDimensionValues(    DimensionDefault    _invoiceDefaultDimension,    DimensionDefault    _purchDefaultDimension,    container           _conName)&#123;    DimensionAttributeValueSetStorage invoiceValueSetStorage    = DimensionAttributeValueSetStorage::find(_invoiceDefaultDimension);    DimensionAttributeValueSetStorage purchValueSetStorage      = DimensionAttributeValueSetStorage::find(_purchDefaultDimension);    for (int i = 1; i &lt;= conLen(_conName); i++)    &#123;        var dimensionAttribute      = DimensionAttribute::findByName(conPeek(_conName, i));        var invoiceDimensionValue   = invoiceValueSetStorage.getDisplayValueByDimensionAttribute(dimensionAttribute.RecId);        var purchDimensionValue     = purchValueSetStorage.getDisplayValueByDimensionAttribute(dimensionAttribute.RecId);        if (purchDimensionValue &amp;&amp; (purchDimensionValue != invoiceDimensionValue))        &#123;            var newDimensionAttributeValue = DimensionAttributeValue::findByDimensionAttributeAndValue(dimensionAttribute, purchDimensionValue, false, true);            invoiceValueSetStorage.removeDimensionAttribute(dimensionAttribute.RecId);            invoiceValueSetStorage.addItem(newDimensionAttributeValue);        &#125;    &#125;        return invoiceValueSetStorage.save();&#125;","categories":["x++"]},{"title":"How To Develop A D365 Number Sequence","url":"/2025/07/11/xpp-numbersequencedevelop/","content":"In Dynamics 365 Finance and Operations, number sequences are essential for generating unique identifiers for business records, such as orders, transactions, or custom entities. In this blog, we‚Äôll walk through how to develop a custom number sequence module step by step.\nStep 1: Create a Custom Number Sequence ClassThe first step is to create a class that extends NumberSeqApplicationModule. This class defines the number sequence logic and configuration.\nHere‚Äôs an example:\n/// &lt;summary&gt;/// HM_SUN-034204_EXT-00189 SPIFF workspace/// Willie Yao - 07/07/2025/// HMSpiffsIdNumSeq/// &lt;/summary&gt;internal final class HMSpiffsIdNumSeq extends NumberSeqApplicationModule&#123;    /// &lt;summary&gt;    /// Subscribe to global number sequence module registration    /// &lt;/summary&gt;    /// &lt;param name=&quot;numberSeqModuleNamesMap&quot;&gt;numberSeqModuleNamesMap&lt;/param&gt;    [SubscribesTo(classstr(NumberSeqGlobal), delegatestr(NumberSeqGlobal, buildModulesMapDelegate))]    static void buildModulesMapSubsciber(Map numberSeqModuleNamesMap)    &#123;        NumberSeqGlobal::addModuleToMap(classnum(HMSpiffsIdNumSeq), numberSeqModuleNamesMap);    &#125;    /// &lt;summary&gt;    /// Return the number sequence module    /// &lt;/summary&gt;    /// &lt;returns&gt;NumberSeqModule&lt;/returns&gt;    public NumberSeqModule numberSeqModule()    &#123;        return NumberSeqModule::CRM;    &#125;    /// &lt;summary&gt;    /// Load number sequence datatype configuration    /// &lt;/summary&gt;    protected void loadModule()    &#123;        NumberSeqDatatype datatype = NumberSeqDatatype::construct();        datatype.parmDatatypeId(extendedTypeNum(HMSpiffsId));        datatype.parmReferenceHelp(literalStr(&quot;@HM:HMTheSPIFFIdentificationReference&quot;));        datatype.parmWizardIsContinuous(false);        datatype.parmWizardIsManual(NoYes::No);        datatype.parmWizardFetchAheadQty(10);        datatype.parmWizardIsChangeDownAllowed(NoYes::No);        datatype.parmWizardIsChangeUpAllowed(NoYes::No);        datatype.parmSortField(1);        datatype.addParameterType(NumberSeqParameterType::DataArea, true, false);        this.create(datatype);    &#125;&#125;\n\nKey Points:\n\nThe class must extend NumberSeqApplicationModule.\n\nUse the buildModulesMapSubsciber method to register your module.\n\nImplement loadModule() to define the configuration.\n\nChoose an appropriate NumberSeqModule (e.g., Sales, Inventory).\n\n\nStep 2: Load the Number Sequence from a Parameter FormOnce your number sequence class is defined, you can call it in a form (typically in a loadModule() method for parameter setup):\nHMSpiffsIdNumSeq spiffsIdNumSeq = new HMSpiffsIdNumSeq();spiffsIdNumSeq.load();\n\nThis code is often placed in the loadModule() method of a parameter setup form class (e.g., MyModuleParameters). This ensures that when number sequences are initialized, your custom identifier logic is registered.\nWith these two simple steps, you‚Äôve successfully extended D365FO with a custom number sequence. This is especially useful for custom business scenarios where the out-of-box sequences don‚Äôt meet your needs.\nIf you need to integrate this with forms, workflows, or auto-numbering during record creation, you can take it a step further by using the NumberSeqReference framework.\n","categories":["x++"],"tags":["NumberSeq"]},{"title":"How to add multiple lookup control to Form Grid","url":"/2025/07/11/xpp-multipleselectionforformgrid/","content":"In some scenarios, we may need to allow users to select multiple values from a lookup within a grid on a form‚Äîfor example, assigning multiple categories or tags to a line-level record. Out of the box, Dynamics 365 Finance and Operations does not support multi-select lookups directly on grid controls. However, we can achieve this behavior by extending the SysLookupMultiSelectGrid framework.\nStep 1: Create a Custom Class Based on SysLookupMultiSelectGridTo begin, we need to create a custom class that extends SysLookupMultiSelectGrid. This class will encapsulate the logic for initializing the lookup, storing selected values, and writing them back to the grid‚Äôs data source.\nHere are the key methods you should implement:\n\ninit(): Register the lookup override and capture context such as the caller data source and field.\n\nlookup(FormStringControl _callerControl): Open the lookup form and load existing values into the selection. After the user makes a selection, update the data source field.\n\ngetSelected(): Return the container of selected record IDs.\n\nsetSelected(): Persist the selected values into a specific field (usually a semicolon-delimited string field).\n\nconstruct(‚Ä¶): A static method to initialize the custom multi-select lookup instance.\n\n\nBy implementing these methods, your custom control can support seamless multi-selection directly from the form grid.\n/// &lt;summary&gt;/// Willie Yao - 07/07/2025/// HMLookupMultiSelectGridOrderCategory/// &lt;/summary&gt;class HMLookupMultiSelectGridOrderCategory extends SysLookupMultiSelectGrid&#123;    FormDataSource              callerDataSource;    FieldId                     callerFieldId;    #define.Spliter(&#x27;;&#x27;)    /// &lt;summary&gt;    /// Willie Yao - 07/07/2025    /// getSelected    /// &lt;/summary&gt;    /// &lt;returns&gt;container&lt;/returns&gt;    public container getSelected()    &#123;        Array       markedRecords;        Common      common;        int         i;        int         recordsMarked = 0;        formDS      = formRun.dataSource();        selectedId  = conNull();        selectedStr = conNull();        for (common = getFirstSelection(formDS); common; common = formDS.getNext())        &#123;            recordsMarked++;        &#125;        if (recordsMarked &gt; 0)        &#123;            markedRecords = formDS.recordsMarked();            for (i = 1; i &lt;= markedRecords.lastIndex(); i++)            &#123;                formDS      = formRun.dataSource();                formDS.setPosition(markedRecords.value(i));                common      = formDS.cursor();                selectedId  += common.RecId;                selectedStr += common.(defaultSelectFieldId);            &#125;        &#125;        return selectedId;    &#125;    /// &lt;summary&gt;    /// Willie Yao - 07/07/2025    /// init    /// &lt;/summary&gt;    public void init()    &#123;        callingControlId.registerOverrideMethod(methodStr(FormStringControl, lookup), methodStr(HMLookupMultiSelectGridOrderCategory, lookup), this);        callerDataSource    = callingControlId.formRun().dataSource(callingControlId.fieldBinding().tableName());        callerFieldId       = callingControlId.fieldBinding().fieldId();    &#125;    /// &lt;summary&gt;    /// Willie Yao - 07/07/2025    /// lookup    /// &lt;/summary&gt;    /// &lt;param name=&quot;_callerControl&quot;&gt;FormStringControl&lt;/param&gt;    public void lookup(FormStringControl _callerControl)    &#123;        FormDataSource  formDataSource;        Common          callerRecord;         if (callerDataSource)        &#123;            selectedId      = conNull();            selectedStr     = conNull();            callerRecord    = callerDataSource.cursor();             if (callerRecord.RecId)            &#123;                HMSpiffs spiffs = callerRecord;                container con = str2con(spiffs.OrderCategory, &#x27;;&#x27;, false);                int i;                for (i = 1; i &lt;= conLen(con); i++)                &#123;                    sunTAFSalesCategory salesCategory = sunTAFSalesCategory::find(conPeek(con, i));                    selectedId += salesCategory.RecId;                    selectedStr += salesCategory.SalesCategoryID;                &#125;            &#125;            else            &#123;                if (callerRecord.validateWrite())                &#123;                    callerRecord.write();                &#125;                else                &#123;                    return;                &#125;            &#125;        &#125;         this.run();         if (callerDataSource)        &#123;            callerRecord.(callerFieldId)    = con2Str(selectedStr, #Spliter);            formDataSource                  = callerRecord.dataSource();            formDataSource.refresh();        &#125;         _callerControl.modified();    &#125;    /// &lt;summary&gt;    /// Willie Yao - 07/07/2025    /// setSelected    /// &lt;/summary&gt;    public void setSelected()    &#123;        Common          callerRecord;         if (callerDataSource)        &#123;            callerRecord    = callerDataSource.cursor();             if (callerRecord)            &#123;                HMSpiffs spiffs = callerRecord;                spiffs.OrderCategory = con2Str(selectedStr, &#x27;;&#x27;);            &#125;        &#125;    &#125;    /// &lt;summary&gt;    /// Willie Yao - 07/07/2025    /// construct    /// &lt;/summary&gt;    /// &lt;param name=&quot;_ctrlId&quot;&gt;ctrlId&lt;/param&gt;    /// &lt;param name=&quot;_query&quot;&gt;query&lt;/param&gt;    /// &lt;param name=&quot;_selectField&quot;&gt;selectField&lt;/param&gt;    /// &lt;returns&gt;HMLookupMultiSelectGridOrderCategory&lt;/returns&gt;    public static HMLookupMultiSelectGridOrderCategory construct(        FormControl _ctrlId,        Query       _query,        container   _selectField = conNull())    &#123;        HMLookupMultiSelectGridOrderCategory lookupMultiSelectControl;         lookupMultiSelectControl = new HMLookupMultiSelectGridOrderCategory();        lookupMultiSelectControl.parmCallingControl(_ctrlId);        lookupMultiSelectControl.parmCallingControlId(_ctrlId);        lookupMultiSelectControl.parmQuery(_query);        lookupMultiSelectControl.parmSelectField(_selectField);        lookupMultiSelectControl.init();         return lookupMultiSelectControl;    &#125;&#125;\n\nStep 2: Use the Lookup Control in the Form GridOnce the custom lookup class is ready, the next step is to integrate it into the form grid where multi-selection is required.\nIn the FormControl method override (usually on the lookup() method of the relevant control), you can instantiate your custom lookup using the construct() method.\nFor example:\nHMLookupMultiSelectGridOrderCategory::construct(MainGrid_OrderCategory, query, con);\n\n\nMainGrid_OrderCategory is the name of the string control (usually bound to a field like OrderCategory) on the form grid.\n\nquery is a standard Query object used to define the records shown in the lookup.\n\ncon is a container specifying which field(s) to select and return from the lookup records.\n\n\nThis setup allows the form to display a multi-select lookup when users interact with the field in the grid, enabling them to choose multiple entries and store them in a semicolon-delimited format (or another structure as needed).\n","categories":["x++"],"tags":["Lookup","Multiple Selection Lookup","Form","Grid"]},{"title":"Query On-Hand inventory using specific inventory-dimensions","url":"/2025/07/08/xpp-onhandinvent/","content":"InventDimOnhandUsing the class InventDimOnhand, you can determine the on-hand inventory of articles and&#x2F;or specific inventory-dimensions. The following job determines the inventory for a specific item and a specific inventlocation. This is grouped per color.\nstatic void getInventOnhandExample(Args _args)&#123;    ItemId itemId;    InventDimOnHand inventDimOnHand;    InventDimParm inventDimParmOnHandLevel;    InventDimOnHandIterator inventDimOnHandIterator;    InventDimOnHandMember inventDimOnHandMember;    InventDim inventDim;    InventDim inventDimCriteria;    InventDimParm inventDimParmCriteria;    // Item: Query specific item    itemId = &quot;DMO003&quot;;        // inventDimCriteria: Apply ranges    inventDimCriteria.wmsLocationId             = &quot;12-1&quot;;    inventDimCriteria.InventBatchId             = &quot;DMOBatch001&quot;;    // inventDimParmCriteria: should values from inventDimCriteria be used?    inventDimParmCriteria.ItemIdFlag            = false;    inventDimParmCriteria.InventSiteIdFlag      = false;    inventDimParmCriteria.InventLocationIdFlag  = false;    inventDimParmCriteria.wmsLocationIdFlag     = true;     // wmsLocationId from inventDimCriteria will be used    inventDimParmCriteria.wmsPalletIdFlag       = false;    inventDimParmCriteria.InventBatchIdFlag     = false;    // inventBatchId from inventDimCriteria will not be used    inventDimParmCriteria.InventSerialIdFlag    = false;    inventDimParmCriteria.ConfigIdFlag          = false;    inventDimParmCriteria.InventSizeIdFlag      = false;    inventDimParmCriteria.InventColorIdFlag     = false;    inventDimParmCriteria.InventStyleIdFlag     = false;    // inventDimParmOnHandLevel: Which dimensions should be used to group for?    // inventDimParmOnHandLevel necessary for inventDimOnHandLevel::DimParm    inventDimParmOnHandLevel.ItemIdFlag            = true;      // necessary    inventDimParmOnHandLevel.InventSiteIdFlag      = false;    inventDimParmOnHandLevel.InventLocationIdFlag  = false;    inventDimParmOnHandLevel.wmsLocationIdFlag     = false;    inventDimParmOnHandLevel.wmsPalletIdFlag       = false;    inventDimParmOnHandLevel.InventBatchIdFlag     = false;    inventDimParmOnHandLevel.InventSerialIdFlag    = false;    inventDimParmOnHandLevel.ConfigIdFlag          = false;    inventDimParmOnHandLevel.InventSizeIdFlag      = false;    inventDimParmOnHandLevel.InventColorIdFlag     = true;      // group by color    inventDimParmOnHandLevel.InventStyleIdFlag     = false;    inventDimOnHand = InventDimOnHand::newAvailPhysical(itemId,                                                        inventDimCriteria,                                                        inventDimParmCriteria,                                                        InventDimOnHandLevel::DimParm,                                                        inventDimParmOnHandLevel);    inventDimOnHandIterator = inventDimOnHand.onHandIterator();    while (inventDimOnHandIterator.more())    &#123;        inventDimOnHandMember = inventDimOnHandIterator.value();        inventDim = InventDim::find(inventDimOnHandMember.parmInventDimId());        info(con2Str([  inventDimOnHandMember.parmItemId(),                        inventDim.InventSiteId,                        inventDim.InventLocationId,                        inventDim.wmsLocationId,                        inventDim.wmsPalletId,                        inventDim.InventBatchId,                        inventDim.InventSerialId,                        inventDim.ConfigId,                        inventDim.InventSizeId,                        inventDim.InventColorId,                        inventDim.InventStyleId,                        inventDimOnHandMember.parmInventQty()]));        inventDimOnHandIterator.next();    &#125;&#125;\n\nInventOnHandBelow function returns onhand qty of item. You can further filter on hand qty of the item for a location by passing invent location id as its optional parameter.\ndisplay InventQtyOnHand qtyOnHand(InventLocationId _inventLocationId = &#x27;&#x27;)&#123;    InventOnHand inventQtyOnHand;    inventQtyOnHand = InventOnHand::newItemId(this.ItemId);    if (_inventLocationId)        inventQtyOnHand.parmInventLocationId(_inventLocationId);    return inventQtyOnHand.availPhysical();&#125;","categories":["x++"]},{"title":"Open in Microsoft Office","url":"/2025/01/18/xpp-open-in-office/","content":"Operation StepThe first step is to implement the OfficeIMenuCustomizer and OfficeIGenerateWorkbookCustomExporter.\n\n\nThe example code is as follows:\n\n\n\n\nFilter SettingDo not use the Recid of the primary table as the filter condition. This will inevitably require the Recid of the primary table to be released, but this will cause an insertion problem for the data entity: since RecId is the primary key of the primary table, it will make an insertion error regardless of any field entered, and will not be able to skip validation.\nIn this case, you can only use other unique keys instead, but many unique indexes contain multiple fields, so you need to create a computed column in the data entity and then construct a computed column field from the multiple fields of the unique index.\n","categories":["x++"]},{"title":"Reverse customer transaction in X++","url":"/2025/07/11/xpp-reversaltrans/","content":"\nReprinted from: https://community.dynamics.com/blogs/post/?postid=d7f28166-cd5f-469c-979c-4dc412212af1\n\nPurposeThe purpose of this document is to demonstrate how we can reverse a posted customer transaction through X++. The code below can be used as a script to automate reversal of posted customer transactions.\nProductDynamics 365 for Finance and Operations.\nDevelopmentCodeclass MAKCustTransReversal extends TransactionReversal_Cust&#123;    public static MAKCustTransReversal construct()    &#123;        return new MAKCustTransReversal();    &#125;    public boolean showDialog()    &#123;        return false;    &#125;    public static void main(Args _args)    &#123;        CustTrans custTrans;        MAKCustTransReversal makCustTransReversal;        ReasonTable reasonTable;        ReasonCode reasonCode;        ReasonRefRecID reasonRefRecID;        InvoiceId invoiceId;        Args args;        ;        invoiceId = &quot;3392&quot;;        reasonCode = &quot;ERROR&quot;;                reasonTable = ReasonTable::find(reasonCode);        reasonRefRecID = ReasonTableRef::createReasonTableRef(            reasonTable.Reason, reasonTable.Description);        custTrans = CustTrans::findFromInvoice(invoiceId);                    if (custTrans.RecId &amp;&amp; !custTrans.LastSettleVoucher)        &#123;            args = new Args();            args.record(custTrans);            makCustTransReversal = MAKCustTransReversal::construct();            makCustTransReversal.parmReversalDate(systemDateGet());            makCustTransReversal.parmReasonRefRecId(reasonRefRecID);            makCustTransReversal.reversal(args);                        info(strFmt(&quot;%1 %2 %3 %4 reversed.&quot;,                custTrans.Voucher,                custTrans.TransDate,                custTrans.Invoice,                custTrans.Txt));        &#125;            &#125;&#125;","categories":["x++"],"tags":["CustTrans","VendTrans","Reversal"]},{"title":"RunBase How to add Records to Include control","url":"/2026/01/11/xpp-runbase-how-to-add-record-to-include/","content":"\n\nThis article also applies to Jobs implemented based on the RunBaseBatch framework.Default assumption: the RunBase Job has caching enabled (pack &#x2F; unpack).\n\n\nBusiness BackgroundIn D365 Finance &amp; Operations, users often want to specify filter criteria through the Records to include control before running a Job, so that only the relevant set of records is processed.\nHowever, in custom RunBase &#x2F; RunBaseBatch Jobs:\n\nThe system does not automatically provide this control by enabling a specific property\nOfficial documentation provides very limited explanation\nMany developers are unclear about the underlying implementation mechanism\n\nThis article demonstrates the simplest implementation approach to correctly add the Records to include control to a RunBase Job, and to ensure it works properly in cached, batch, and new session scenarios.\n\nKey ImplementationStep 1: Declare a global QueryRun variableQueryRun gQueryRun;\n\n\nThis variable is used to:\n\nHold the query conditions configured by the user in the UI\nDrive the business logic during the run() phase\nSupport serialization via pack &#x2F; unpack\n\n\n\nStep 2: Initialize QueryRunpublic void new()&#123;    Query query = new Query(queryStr(SalesLine));    // The Query can be constructed using a Simple Query or QueryBuildDataSource    gQueryRun = new QueryRun(query);&#125;\n\nNotes:\n\nQueryRun must be initialized during construction\nAt least one DataSource is required; otherwise, the Records to include UI cannot be generated\n\n\nStep 3: Override the queryRun() methodpublic QueryRun queryRun()&#123;    return gQueryRun;&#125;\n\n\nThis method must return the global variable gQueryRun; otherwise, the Records to include control will not function.\n\n\nStep 4: Override the showQueryValues() methodpublic boolean showQueryValues()&#123;    return true;&#125;\n\nPurpose:\n\nControls whether Records to include is displayed in the Dialog\nReturning true is a required condition for showing this control\n\n\nStep 5: Override the pack() methodpublic container pack()&#123;    return [#CurrentVersion, gQueryRun.pack()];&#125;\n\nKey points:\n\nQueryRun must be serialized\nOtherwise, query conditions will be lost when running in Batch or in a new session\n\n\nStep 6: Override the unpack() methodpublic boolean unpack(container _packedClass)&#123;    Version version = RunBase::getVersion(_packedClass);    container conQuery;    switch (version)    &#123;        case #CurrentVersion:            [version, conQuery] = _packedClass;            Query query = new Query(conQuery);            gQueryRun = new QueryRun(query);            break;        default:            return false;    &#125;    return true;&#125;\n\nNotes:\n\nDuring unpack, both Query and QueryRun must be reconstructed\nExisting object instances must not be reused directly\n\n\nBy following the six steps above, you can successfully add the Records to include control to a RunBase Job.\n\nResult ValidationAfter opening the Job, if the Records to include query area appears in the Dialog, the control has been successfully added and is functioning correctly.\n\n\n\nUsing QueryRun in run()public void run()&#123;    while (gQueryRun.next())    &#123;        // Business logic    &#125;&#125;\n\nNotes:\n\ngQueryRun should be used directly in run()\nDo not reconstruct the Query, otherwise the user-defined conditions will be ignored\n\n\nSummary\nRunBase does not automatically manage Query objects\nRecords to include relies on queryRun() + showQueryValues()\nQueryRun must support pack &#x2F; unpack\nIn Batch &#x2F; RunInNewSession scenarios, always verify that query conditions are applied correctly\n\n","categories":["x++"],"tags":["RunBase"]},{"title":"RunBase How to enable the caching mechanism (pack/unpack)","url":"/2026/01/11/xpp-runbase-how-to-enable-cache-mechanism/","content":"How to Enable Caching (pack &#x2F; unpack) in RunBase\nThis article also applies to Jobs implemented using the RunBaseBatch framework.\n\n\nBusiness BackgroundIn D365 Finance &amp; Operations, RunBase is commonly used to implement parameterized business operations or batch Jobs. To ensure a good user experience and functional completeness, caching (pack &#x2F; unpack) must be enabled in the following scenarios:\n\nWhen the Records to include control is required, allowing users to enter filter criteria for business tables (i.e., enabling Query);\nWhen the Job needs to run in a new session (RunInNewSession);\nWhen the Job must support Run in Batch execution.\n\nFrom an implementation perspective, caching is essentially the serialization and deserialization of RunBase member variables. These member variables typically correspond to the parameters exposed to users in the Dialog.\nThis article demonstrates the simplest and standard implementation approach to correctly enable caching in a RunBase Job, while avoiding common implementation pitfalls.\n\nKey ImplementationStep 1: Use macros to manage member variablesprotected TransDate gTransDate; // Member variable#DEFINE.CurrentVersion(1) // #CurrentVersion represents the cache version number, defined as 1 in this example#LOCALMACRO.CurrentList // #CurrentList is used to centrally manage member variables that need to be cached// Note: container-type variables must not be included here    gTransDate#ENDMACRO\n\nNotes:\n\nUsing macros significantly improves maintainability\nWhen parameters change, only #CurrentList needs to be updated\ncontainer-type variables must be handled separately and cannot be placed directly in the macro list\n\n\nStep 2: Override the pack() methodpublic container pack()&#123;    return [#CurrentVersion, #CurrentList];&#125;\n\nImplementation details:\n\nThe return value must be a container\nIt is recommended to always store the version number first to support future extensions\n\n\nStep 3: Override the unpack() methodpublic boolean unpack(container _packedClass)&#123;    Version version = RunBase::getVersion(_packedClass);    switch (version)    &#123;        case #CurrentVersion:            [version, #CurrentList] = _packedClass;            break;        default:            return false;    &#125;    return true;&#125;\n\nNotes:\n\nRunBase::getVersion() is used to safely parse the cache structure\nThis is a key mechanism for supporting Job upgrades and backward compatibility\n\n\nSpecial Case: Caching with QueryRun\nWhen a Job enables the Records to include control, a QueryRun member variable is typically introduced.Since QueryRun cannot be stored directly using macros, it must be handled separately.\n\n\nStep 1: Declare member variablesprotected TransDate gTransDate;QueryRun queryRun;#DEFINE.CurrentVersion(1)#LOCALMACRO.CurrentList    gTransDate#ENDMACRO\n\n\nStep 2: Override the pack() methodpublic container pack()&#123;    return [#CurrentVersion, #CurrentList, queryRun.pack()];&#125;\n\nKey points:\n\nQueryRun must be packed separately using pack()\nThe order must be consistent with the unpack() method\n\n\nStep 3: Override the unpack() methodpublic boolean unpack(container _packedClass)&#123;    Version version = RunBase::getVersion(_packedClass);    container conQuery;    switch (version)    &#123;        case #CurrentVersion:            [version, #CurrentList, conQuery] = _packedClass;            Query query = new Query(conQuery);            queryRun = new QueryRun(query);            break;        default:            return false;    &#125;    return true;&#125;\n\nNotes:\n\nDuring unpack, both Query and QueryRun must be reconstructed\nExisting object instances must not be reused\n\n\nResult Validation\nOpen the Job;\n\n\n\n\nEnter parameter values and click OK;\n\nAfter successful execution, reopen the Job. The parameter values should default to the values entered during the previous run;\n\n\nThese results indicate that:\n\npack &#x2F; unpack is working correctly\nparameters are correctly restored in new session and Batch scenarios\n\n\nSummary\nRunBase does not automatically enable caching; pack / unpack must be explicitly implemented by the developer;\nObjects that need to be cached are typically member variables exposed in the Dialog;\nUsing macros to manage cached fields is strongly recommended to improve maintainability;\nQueryRun is a special case and must be packed and unpacked separately;\nIf a Job supports RunInNewSession &#x2F; RunInBatch &#x2F; Records to include, caching is mandatory rather than optional.\n\n","categories":["x++"],"tags":["RunBase"]},{"title":"RunBaseBatch How to enable \"Run In Batch\"","url":"/2026/01/11/xpp-runbasebatch-how-to-enable-run-in-batch/","content":"How to Enable Run In Batch in RunBaseBatch\nFrom a minimal implementation perspective, RunBaseBatch and RunBase Jobs are implemented in a highly similar way.This article explains how to correctly enable Run In Batch in RunBaseBatch using the standard implementation approach.\nNote: The examples in this article are based on RunBaseBatch, and the minimal implementation version is not repeated here.\n\n\nBusiness BackgroundIn D365 Finance &amp; Operations, when a business process has the following characteristics, it is typically designed as a Batch Job:\n\nLong execution time\nComplex logic involving large volumes of data processing\nNot suitable for blocking the user interaction interface\n\nRunBaseBatch is a standard framework provided by D365 that allows a RunBase Job to be seamlessly upgraded into a batch-capable Job, with built-in support for:\n\nRun In Batch\nBatch group\nExecution in a new session\n\nHowever, this is only true if the implementation follows the framework‚Äôs expectations.This article focuses on which methods must call super() and why this is critical for enabling Run In Batch.\n\nKey ImplementationStep 1: Inherit from RunBaseBatchpublic class HM365RunBaseBatch extends RunBaseBatch&#123;    ...&#125;\n\nNotes:\n\nOnly by inheriting from RunBaseBatch will the system recognize the Job as batch-capable\nInheriting from RunBase alone is not sufficient to enable Run In Batch\n\n\nStep 2: Ensure new() calls super()public void new()&#123;    Query query = new Query(queryStr(SalesLine));    queryRun = new QueryRun(query);    super();     // Calling the base class constructor is mandatory    // RunBaseBatch initializes BatchInfo and other critical objects here&#125;\n\nKey points:\n\nsuper() is not optional\n\nIf omitted:\n\nRun In Batch will not appear in the Dialog\nThe Job will not be correctly registered as a Batch task\n\n\nThis is a very common but subtle mistake\n\n\n\nStep 3: Ensure dialog() calls super()public Object dialog()&#123;    DialogRunbase dialog = super();    gDialogTransDate = dialog.addFieldValue(        extendedTypeStr(TransDate),        gTransDate    );    return dialog;&#125;\n\nNotes:\n\nsuper() is responsible for constructing the Batch-related areas of the Dialog\n\nIf not called:\n\nEven if the Job inherits from RunBaseBatch\nBatch options will not be displayed in the Dialog\n\n\n\n\nStep 4: Ensure getFromDialog() calls super()public boolean getFromDialog()&#123;    boolean ret = super();    gTransDate = gDialogTransDate.value();    return ret;&#125;\n\nNotes:\n\nsuper() reads Batch-related parameters\n\nIf omitted:\n\nRun In Batch settings may not be correctly parsed\nBatch Job behavior may not match expectations\n\n\n\n\nResult ValidationAfter the above steps are implemented correctly, opening the Job Dialog should display the Run In Batch options:\n\n\nThis confirms that:\n\nThe RunBaseBatch initialization flow is complete\nBatchInfo has been successfully constructed\nThe Job can be submitted and executed as a Batch Job\n\n\nSummary\nEnabling Run In Batch requires inheriting from RunBaseBatch, not RunBase;\nCalling super() in new(), dialog(), and getFromDialog() is mandatory, not a matter of coding style;\nThe super() call chain contains critical logic for BatchInfo initialization and Batch parameter construction;\nEven if the code compiles and runs, missing any required super() call may result in Run In Batch being ‚Äúvisible but ineffective‚Äù;\nIn real projects, around 80% of RunBaseBatch issues are caused by incomplete initialization rather than business logic errors.\n\n","categories":["x++"],"tags":["RunBaseBatch"]}]