[{"title":"利用 Microsoft Entra ID 保护 API","url":"/2025/03/29/API/","content":"利用 Microsoft Entra ID 保护 API\nMicrosoft Entra ID 旧名字是 Azure AD，详细信息请阅读官方文档：[Microsoft Entra ID 微软官方文档](Microsoft 标识平台文档 - Microsoft identity platform | Microsoft Learn)\nJWT (JSON Web Token) 为轻量级的认证方案，具体原理请看：一文读懂 JWT\n基于ASP.NET Web API2框架架构，设计并实现了 Microsoft Entra ID 身份认证与 JWT 令牌授权的双重安全机制，形成完整的API接口防护体系，确保服务调用的合法性与数据交互的安全性。\n\n基于 JWT 身份验证与授权\n本文所有的代码为 C#，但方法是通用的，可基于不同的平台和语言进行变换。\n\n1.安装必要的 Nuget 包\nSystem.IdentityModel.Tokens.Jwt\n\nMicrosoft.Owin.Security.Jwt\n\nMicrosoft.AspNet.WebApi.Owin\n\nMicrosoft.Owin.Host.SystemWeb\n\n\n2.创建 JWT 生成工具类public class JwtManager&#123;  private static readonly string SecretKey = &quot;your-secret-key-至少32位长度&quot;; *//* *实际部署时请替换为安全密钥*  public static string GenerateToken(string username, string role, int expireMinutes = 60)  &#123;        var securityKey = new SymmetricSecurityKey(Convert.FromBase64String(SecretKey));        var credentials = new SigningCredentials(securityKey, SecurityAlgorithms.HmacSha256);        var claims = new[]        &#123;              new Claim(ClaimTypes.Name, username),              new Claim(ClaimTypes.Role, role),              new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())        &#125;;        var token = new JwtSecurityToken(            issuer: &quot;your-api&quot;,            audience: &quot;client-app&quot;,            claims: claims,            expires: DateTime.UtcNow.AddMinutes(expireMinutes),            signingCredentials: credentials        );        return new JwtSecurityTokenHandler().WriteToken(token);  &#125;&#125;\n\n3.配置 OWIN 中间件[assembly: OwinStartup(typeof(YourNamespace.Startup))]namespace YourNamespace&#123;    public class Startup    &#123;        public void Configuration(IAppBuilder app)        &#123;            // 配置 JWT 验证            var jwtOptions = new JwtBearerAuthenticationOptions            &#123;                AuthenticationMode = AuthenticationMode.Active,                TokenValidationParameters = new TokenValidationParameters()                &#123;                    ValidateIssuer = true,                    ValidIssuer = &quot;your-api&quot;,                    ValidateAudience = true,                    ValidAudience = &quot;client-app&quot;,                    ValidateIssuerSigningKey = true,                    IssuerSigningKey = new SymmetricSecurityKey(                        Convert.FromBase64String(JwtManager.SecretKey)),                    ValidateLifetime = true                &#125;            &#125;;            app.UseJwtBearerAuthentication(jwtOptions);            // 初始化 Web API            HttpConfiguration config = new HttpConfiguration();            WebApiConfig.Register(config);            app.UseWebApi(config);        &#125;    &#125;&#125;\n\n4.创建登录接口public class LoginRequest&#123;    public string Username &#123; get; set; &#125;    public string Password &#123; get; set; &#125;&#125;[RoutePrefix(&quot;api/auth&quot;)]public class AuthController : ApiController&#123;    [HttpPost]    [Route(&quot;login&quot;)]    [AllowAnonymous]    [ResponseType(typeof(string))]    public IHttpActionResult Login(LoginRequest request)    &#123;        // 示例验证逻辑（实际需替换为数据库验证）        if (request.Username == &quot;admin&quot; &amp;&amp; request.Password == &quot;admin123&quot;)        &#123;            var token = JwtManager.GenerateToken(request.Username, &quot;Admin&quot;);            return Ok(new &#123; Token = token &#125;);        &#125;        return Unauthorized(); // 401 未授权    &#125;&#125;\n\n5.保护 API 断点[RoutePrefix(&quot;api/protected&quot;)][Authorize] // 整个控制器需要认证public class ProtectedController : ApiController&#123;    [HttpGet]    [Route(&quot;admin&quot;)]    [Authorize(Roles = &quot;Admin&quot;)] // 仅允许 Admin 角色访问    public IHttpActionResult AdminOnly()    &#123;        var username = User.Identity.Name;        return Ok($&quot;Hello Admin &#123;username&#125;!&quot;);    &#125;    [HttpGet]    [Route(&quot;user&quot;)]    public IHttpActionResult AnyAuthenticatedUser()    &#123;        return Ok($&quot;Welcome &#123;User.Identity.Name&#125;!&quot;);    &#125;&#125;\n\n基于 Open ID Connecttion 和 Azure AD 的授权官方文档：OAuth 2.0 和 OpenID Connect 协议 - Microsoft identity platform | Microsoft Learn\n1.在 Azure Entra Admin Center 创建租户官方文档：Quickstart: Call a web API that is protected by the Microsoft identity platform - Microsoft identity platform | Microsoft Learn\n\n登录到 Azure Entra Admin Center；\n找到左侧的 Identity &gt; Applications &gt; App registrations；\n点击 New registration；a) 在 Name 输入显示名称；如：Reg_01；b) Supported account types 选择只允许当前组织的账号；c) 重定向 URI 选择 Web 类型，并输入如下三个 uri (以开发环境版本为例):​              i. http://localhost:8080/​             ii. http://localhost:8080/signin-oidc​            iii. http://localhost:8080/signout-callback-oidc\n创建完成后，进入 detail 页面点击 Authentication；a) 将 ID tokens 选中并保存\n进入 Certificates &amp; Secrets &gt; Client Secrets。创建新的客户端密钥，并复制密钥值；\n进入 Overview，将 Application ID 与 Tenant ID 复制下来备用;\n\n2.在 ASP.NET使用OpenIdConnectAuthenticationOptionspublic class Startup&#123;    private string clientId = &quot; clientId &quot;;    private string tenantId = &quot; tenantId &quot;;    private string clientSecret = &quot; clientSecret &quot;;    public void Configuration(IAppBuilder app)    &#123;      \t app.SetDefaultSignInAsAuthenticationType(CookieAuthenticationDefaults.AuthenticationType);        app.UseCookieAuthentication(new CookieAuthenticationOptions &#123;            AuthenticationType = CookieAuthenticationDefaults.AuthenticationType,            CookieManager = new SystemWebCookieManager(), // 修复 Cookie 管理问题            CookieSameSite = SameSiteMode.None,            CookieSecure = CookieSecureOption.SameAsRequest,            ExpireTimeSpan = TimeSpan.FromMinutes(60)        &#125;);            配置 Azure AD OpenID Connect 认证        app.UseOpenIdConnectAuthentication(new OpenIdConnectAuthenticationOptions        &#123;            AuthenticationMode = AuthenticationMode.Active,            ClientId = clientId,            ClientSecret = clientSecret,            Authority = $&quot;https://login.microsoftonline.com/&#123;tenantId&#125;/v2.0&quot;,            RedirectUri = &quot;http://localhost:60026/signin-oidc&quot;,            PostLogoutRedirectUri = &quot;http://localhost:60026/&quot;,            Scope = OpenIdConnectScope.OpenIdProfile + &quot; email&quot;,            ResponseType = OpenIdConnectResponseType.CodeIdToken,            TokenValidationParameters = new TokenValidationParameters            &#123;                ValidateIssuer = true,                ValidIssuer = $&quot;https://sts.windows.net/&#123;tenantId&#125;/&quot;            &#125;,                            Notifications = new OpenIdConnectAuthenticationNotifications            &#123;                AuthorizationCodeReceived = async context =&gt;                &#123;                    try                    &#123;                        // 1. 获取 Token                        var authContext = new AuthenticationContext($&quot;https://login.microsoftonline.com/&#123;tenantId&#125;&quot;);                        var clientCredential = new ClientCredential(clientId, clientSecret);                        var result = await authContext.AcquireTokenByAuthorizationCodeAsync(                            context.Code,                            new Uri(context.RedirectUri),                            clientCredential);                        System.Diagnostics.Debug.WriteLine($&quot;Access Token: &#123;result.AccessToken&#125;&quot;);                                                 context.AuthenticationTicket.Identity.AddClaim(new Claim(&quot;access_token&quot;, result.AccessToken));                    &#125;                    catch (Exception ex)                    &#123;                        // 记录错误日志                        System.Diagnostics.Trace.TraceError($&quot;Token 获取失败: &#123;ex&#125;&quot;);                        context.HandleResponse();                        context.Response.Redirect(&quot;/Error?code=token_failure&quot;);                    &#125;                                        &#125;,                AuthenticationFailed = context =&gt;                &#123;                    System.Diagnostics.Trace.TraceError($&quot;认证失败: &#123;context.Exception&#125;&quot;);                    context.HandleResponse();                    context.Response.Redirect(&quot;/Error?message=&quot; + context.Exception.Message);                    return Task.CompletedTask;                &#125;            &#125;        &#125;);         // 初始化 Web API        HttpConfiguration config = new HttpConfiguration();        WebApiConfig.Register(config);        app.UseWebApi(config);    &#125;&#125;\n\n上述代码是在启动之前配置并启用 Azure AD OpenID Connect 认证服务。\n\n创建登录接口\n\n\npublic class AccountController : Controller&#123;    public void Login()    &#123;        if (!Request.IsAuthenticated)        &#123;            // 触发 Azure AD 登录            HttpContext.GetOwinContext().Authentication.Challenge(                new AuthenticationProperties &#123; RedirectUri = &quot;/&quot; &#125;,                OpenIdConnectAuthenticationDefaults.AuthenticationType);        &#125;    &#125;    public void Logout()    &#123;        // 注销本地 Cookie 和 Azure AD 会话        HttpContext.GetOwinContext().Authentication.SignOut(            CookieAuthenticationDefaults.AuthenticationType,            OpenIdConnectAuthenticationDefaults.AuthenticationType);    &#125;&#125;\n\n基于 JWT 与 Azure AD 设置授权上面两章我们学习了如何使用 JWT 与 Azure AD(也称 Azure Entra)；当我们正在开发一个最小 API 服务，并想要使用 JWT 对 API 进行授权时，也需要调用该 API 的客户端拥有特定的权限。\n这就需要组合使用 Azure AD (Azure Entra) 与 JWT 。\n整个授权的流程图如下：\n\n\n\n客户端在调用API前首先需要向授权服务器 (Azure Entra) 发出授权认证申请；\n\n授权服务器得到申请并验证成功后会返回 access token；\n\n客户端在调用API时会带上 access token；\n\nAPI 服务接收到请求后，会向授权服务器验证 access token，在验证成功后会响应给客户端。\n\n\n1.启用 JWT\n在 startup 配置启用 JwtBearerAuthenticationOptions；\n\napiApp.UseJwtBearerAuthentication(new JwtBearerAuthenticationOptions&#123;    TokenValidationParameters = new TokenValidationParameters    &#123;        ValidIssuer = $&quot;https://sts.windows.net/&#123;tenantId&#125;/&quot;,        ValidAudience = &quot;api://&quot; + clientId,        IssuerSigningKeyResolver = (token, securityToken, kid, validationParameters) =&gt;        &#123;            var metadataAddress = $&quot;https://login.microsoftonline.com/&#123;tenantId&#125;/.well-known/openid-configuration&quot;;            var metadata = new ConfigurationManager&lt;OpenIdConnectConfiguration&gt;(                metadataAddress,                new OpenIdConnectConfigurationRetriever()            ).GetConfigurationAsync().Result;            return metadata.SigningKeys;        &#125;    &#125;&#125;);\n\n\n使用 [Authorize] 注解标记接口，代表调用它之前需要 JWT 授权；\n\npublic class TestController : ApiController&#123;    [Authorize] // 要求 JWT 授权    [HttpGet]    [Route(&quot;api/test&quot;)]    public IHttpActionResult GetData()    &#123;        return Ok(new &#123; message = &quot;API 认证成功！&quot; &#125;);    &#125;&#125;\n\n2.配置 Azure AD2.1 注册客户端应用步骤 1：注册客户端应用\n\n返回 应用注册 → 新注册。\n名称：输入客户端应用名称（例如 MyClientApp）。\n支持的账户类型：选择 仅此组织目录中的账户。\n重定向 URI：选择 Web，输入 http://localhost（本地测试用）。\n点击 注册。\n\n\n\n步骤 2：配置客户端凭据\n\n在客户端应用页面中，进入 证书和密码 → 客户端密码 → 新建客户端密码。\n说明：输入名称（例如 MyClientSecret）。\n过期时间：选择有效期（例如 6 个月）。\n点击 添加。\n\n\n复制客户端密码值：保存此值（稍后无法再查看）。\n\n2.2 注册服务端应用\n如果还没有服务端的 registration，可以按照上述的步骤一注册新的应用。\n\n\n进入 ​API 权限 → ​添加权限 → ​我的 API；\n选择之前注册的 API 应用（例如 MyProtectedAPI）；\n选择 ​委托的权限 或 ​应用程序权限；\n委托的权限：用户登录后访问 API（例如 access_as_api）；\n应用程序权限：后台服务直接访问 API（无需用户登录）；\n点击 ​添加权限。\n\n2.3 测试利用 postman 代替客户端进行测试，需要注意以下几点：\n\nClient_id 需要填客户端的 application id；\nClient_secret 需要填客户端的 secret；\nScope 需要填服务端的 scope。\n\n\nJavascript 请求示例代码如下：\nconst tokenUrl = `https://login.microsoftonline.com/$&#123;pm.environment.get(&quot;tenant_id&quot;)&#125;/oauth2/v2.0/token`;const clientId = pm.environment.get(&quot;client_id&quot;);const clientSecret = pm.environment.get(&quot;client_secret&quot;);const scope = pm.environment.get(&quot;api_audience&quot;) + &quot;/.default&quot;;pm.sendRequest(&#123;  url: tokenUrl,  method: &#x27;POST&#x27;,  header: &#123; &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27; &#125;,  body: &#123;    mode: &#x27;urlencoded&#x27;,    urlencoded: [      &#123; key: &#x27;client_id&#x27;, value: clientId &#125;,      &#123; key: &#x27;client_secret&#x27;, value: clientSecret &#125;,      &#123; key: &#x27;scope&#x27;, value: scope &#125;,      &#123; key: &#x27;grant_type&#x27;, value: &#x27;client_credentials&#x27; &#125;    ]  &#125;&#125;, (err, res) =&gt; &#123;  if (!err) &#123;    pm.environment.set(&quot;access_token&quot;, res.json().access_token);  &#125;&#125;);\n\n\n获取 token 后，将 token 带入到请求中即可\nhttp://localhost:60026/api/test\nbearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6IkpETmFfNGk0cjdGZ2lnTDNzS……\n\n","categories":["asp.net"]},{"title":"微软【AI-900】考试准备系列博客一","url":"/2025/02/24/ai-900-exam-preparation-1/","content":"Microsoft Azure 人工智能基础：人工智能概述第一部分人工智能介绍人工智能使我们能够构建令人惊叹的软件，这些软件可以改善医疗保健，使人们能够克服身体上的缺点，增强智能基础设施，创造令人难以置信的娱乐体验，甚至拯救地球！\n什么是人工智能？简单地说，人工智能是一种模仿人类行为和能力的软件。主要工作负载包括：\n\n机器学习：这通常是人工智能系统的基础，也是我们“教”计算机模型做出预测并从数据中得出结论的方式\n计算机视觉：人工智能通过摄像头、视频和图像从视觉上解读世界的能力\n自然语言处理：在人工智能中，计算机能够解释书面或口头语言，并以实物回应\n文档智能：人工智能中的功能，用于管理、处理和使用表单和文档中的大量数据\n知识挖掘：人工智能从大量非结构化数据中提取信息的能力，以创建可搜索的知识存储\n生成式人工智能：人工智能中的功能，可以创建各种格式的原创内容，包括自然语言、图像、代码等\n\n理解机器学习机器学习是大多数人工智能解决方案的基础。自20世纪50年代以来，研究人员（通常被称为数据科学家）一直在研究人工智能的不同方法。人工智能的大多数现代应用都起源于机器学习，这是人工智能的一个分支，结合了计算机科学和数学。\n让我们从一个现实世界的例子开始，看看如何使用机器学习来解决一个难题。\n可持续农业技术对于最大限度地提高粮食产量，同时保护脆弱的环境至关重要。澳大利亚农业科技公司The Yield利用传感器、数据和机器学习来帮助农民做出与天气、土壤和植物条件相关的明智决策。\n机器学习如何工作那么机器是如何学习的呢？\n答案是，从数据中。在当今世界，我们在日常生活中创造了大量的数据。从我们发送的短信、电子邮件和社交媒体帖子，到我们在手机上拍摄的照片和视频，我们产生了大量的信息。在我们的家庭、汽车、城市、公共交通基础设施和工厂中，数以百万计的传感器仍在创造更多的数据。\n数据科学家可以使用所有这些数据来训练机器学习模型，这些模型可以根据他们在数据中发现的关系进行预测和推断。\n机器学习模型试图捕捉数据之间的关系。例如，假设一个环境保护组织希望志愿者使用手机应用程序识别和分类不同种类的野花。下面的动画展示了如何使用机器学习来实现这一场景。\n\n\n\n一个由植物学家和科学家组成的团队收集野花样本的数据\n研究小组给样品贴上了正确的物种标签\n使用一种算法处理标记的数据，该算法可以找到样本特征与标记物种之间的关系\n算法的结果被封装在一个模型中\n当志愿者发现新的样本时，该模型可以识别正确的物种标签\n\n人工智能的方法已经发展到可以完成更复杂的任务。这些复杂的模型构成了人工智能能力的基础。\n在 Microsoft Azure 中的机器学习微软Azure提供Azure机器学习服务——一个基于云的平台，用于创建、管理和发布机器学习模型。Azure Machine Learning Studio提供多种创作体验，例如：\n\n自动化机器学习：该功能使非专家能够从数据中快速创建有效的机器学习模型\nAzure机器学习设计器：一个图形界面，支持机器学习解决方案的无代码开发\n数据度量可视化：用可视化分析和优化您的实验\n笔记本：在直接集成在studio中的托管 Jupyter Notebook 服务器中编写和运行自己的代码\n\n第二部分理解计算机视觉计算机视觉是人工智能的一个领域，处理视觉处理。让我们来探索一下计算机视觉带来的一些可能性。\nSeeing AI应用程序是计算机视觉力量的一个很好的例子。这款应用专为盲人和低视力群体设计，利用人工智能的力量打开视觉世界，描述附近的人、文字和物体。\n计算机视觉模型和功能大多数计算机视觉解决方案都是基于机器学习模型的，这些模型可以应用于来自相机、视频或图像的视觉输入。下表描述了常见的计算机视觉任务。\n\n\n\n任务\n描述\n\n\n\n图像分类\n图像分类包括训练机器学习模型根据图像的内容对图像进行分类。例如，在交通监控解决方案中，您可能会使用图像分类模型，根据图像包含的车辆类型（如出租车、公共汽车、骑自行车的人等）对图像进行分类。\n\n\n对象检测\n训练对象检测机器学习模型对图像中的单个对象进行分类，并使用边界框识别它们的位置。例如，交通监控解决方案可能使用对象检测来识别不同类别车辆的位置。\n\n\n语义分解\n语义分割是一种先进的机器学习技术，其中图像中的单个像素根据它们所属的对象进行分类。例如，一个交通监控解决方案可能会用“掩模”层覆盖交通图像，用特定的颜色突出显示不同的车辆。\n\n\n图像分析\n您可以创建将机器学习模型与高级图像分析技术相结合的解决方案，以从图像中提取信息，包括可以帮助对图像进行分类的“标签”，甚至是总结图像中显示的场景的描述性说明。\n\n\n人脸识别，分析和识别\n人脸检测是物体检测的一种特殊形式，它在图像中定位人脸。这可以与分类和面部几何分析技术相结合，根据面部特征识别个体。\n\n\n光学学符识别（OCR）\n光学字符识别是一种用于检测和读取图像中的文本的技术。您可以使用OCR读取照片中的文本（例如，道路标志或商店门面），或者从扫描的文档（例如信件、发票或表单）中提取信息。\n\n\n在 Microsoft Azure 中的计算机视觉服务你可以使用微软的Azure AI Vision来开发计算机视觉解决方案。这些服务特性可以在Azure Vision Studio和其他编程语言中使用和测试。Azure AI Vision的一些功能包括：\n\n图像分析：分析图像和视频，提取描述、标签、对象和文本的功能。\n面部：使您能够构建面部检测和面部识别解决方案的功能。\n光学字符识别（OCR）：从图像中提取打印或手写文本的功能，从而可以访问扫描文本的数字版本。\n\n第三部分理解自然语言处理自然语言处理（NLP）是人工智能的一个领域，用于创建能够理解书面和口头语言的软件。\nNLP使您能够创建以下软件：\n\n分析和解释文档、电子邮件和其他来源的文本。\n口译口语，并综合言语反应。\n自动翻译语言之间的口头或书面短语。\n解释命令并决定适当的行动。\n\n例如，《Starship Commander》是一款发生在科幻世界中的虚拟现实（VR）游戏。游戏使用自然语言处理，让玩家能够控制剧情，并与游戏角色和星际飞船系统互动。\n在 Microsoft Azure 中的自然语言处理你可以使用微软的Azure AI语言来构建自然语言处理解决方案。Azure AI Language的一些功能包括理解和分析文本，训练能够理解口语或基于文本的命令的会话语言模型，以及构建智能应用程序。\n微软的Azure AI Speech是另一项可用于构建自然语言处理解决方案的服务。Azure AI语音功能包括语音识别和合成、实时翻译、对话转录等。\n微软的Azure人工智能翻译器使用神经机器翻译（NMT）模型进行翻译，分析文本的语义上下文，从而提供更准确、更完整的翻译。\n您可以在Azure语言工作室中探索Azure AI语言功能，在Azure Language Studio中探索Azure AI语音功能。服务功能可以在工作室和其他编程语言中使用和测试。\n理解文档智能和知识挖掘文档智能是人工智能的一个领域，用于管理、处理和使用在表格和文档中发现的大量各种数据。文档智能使您能够创建能够自动处理合同、健康文件、财务表格等的软件\n在 Microsoft Azure 中的文档智能你可以使用微软的Azure AI文档智能来构建管理和加速扫描文档数据收集的解决方案。Azure AI文档智能的特性有助于自动化应用程序和工作流中的文档处理，增强数据驱动策略，并丰富文档搜索功能。您可以使用预构建的模型为发票、收据、健康保险卡、税务表格等添加智能文档处理。你还可以使用Azure AI Document Intelligence用你自己的标记数据集创建自定义模型。服务特性可以在文档智能工作室和其他编程语言中使用和测试。\n\n\n知识挖掘知识挖掘是一个术语，用于描述从大量非结构化数据中提取信息以创建可搜索的知识存储的解决方案。\n在 Microsoft Azure 中进行知识挖掘微软的一个知识挖掘解决方案是Azure AI Search，这是一个私有的企业搜索解决方案，拥有构建索引的工具。这些索引可以仅供内部使用，或者在面向公众的互联网资产上启用可搜索的内容。\nAzure AI Search可以利用Azure AI服务的内置AI功能，如图像处理、文档智能和自然语言处理来提取数据。该产品的人工智能功能可以索引以前无法搜索的文档，并快速从大量数据中提取和显示见解。\n第四部分理解生成式 AI生成式人工智能描述了人工智能中创造原创内容的一类功能。人们通常与内置在聊天应用程序中的生成式人工智能进行交互。生成式人工智能应用程序接受自然语言输入，并以各种格式（包括自然语言、图像、代码和音频）返回适当的响应。\n在 Microsoft Azure 中的生成式 AI在Microsoft Azure中，您可以使用Azure OpenAI服务来构建生成式AI解决方案。Azure OpenAI服务是微软用于部署、定制和托管生成AI模型的云解决方案。它将OpenAI最先进的模型和api与Azure云平台的安全性和可扩展性结合在一起。\nAzure OpenAI支持许多基础模型选择，可以满足不同的需求。这些服务功能可以在Azure AI Foundry上使用和测试，Azure AI Foundry是微软设计企业级AI解决方案的平台。您可以使用Azure AI Foundry门户来管理、开发和自定义生成AI模型。\n第五部分人工智能的挑战与风险人工智能是一个强大的工具，可以用来极大地造福世界。然而，像任何工具一样，必须负责任地使用它。\n下表显示了人工智能应用程序开发人员面临的一些潜在挑战和风险。\n","categories":["ai"]},{"title":"微软【AI-900】考试准备系列博客二","url":"/2025/02/25/ai-900-exam-preparation-2/","content":"Microsoft Azure AI 基础第一部分什么是机器学习机器学习起源于数据的统计和数学建模。 机器学习的基本理念是使用过去观测到的数据来预测未知的结果或值。 例如：\n\n冰淇淋店的老板可能会使用某个应用，结合历史销售和天气记录，根据天气预报来预测他们在某一天可能会售出多少个冰淇淋。\n医生可能会使用以往患者的临床数据来运行自动测试，以根据体重、血糖水平和其他测量值等因素来预测新患者是否有患糖尿病的风险。\n南极研究人员可能会利用过去的观测值，根据鸟类脚蹼、喙和其他物理属性的测量，自动识别不同的企鹅物种（例如阿德利企鹅、白眉企鹅或帽带企鹅）。\n\n机器学习作为一种函数由于机器学习基于数学和统计学，因此通常会使用数学术语来思考机器学习模型。 从根本上讲，机器学习模型是一种软件应用程序，它封装一个函数用于根据一个或多个输入值计算输出值。 定义该函数的过程称为训练。 定义函数后，可以使用它在称为“推理”的过程中预测新值。\n让我们探讨一下训练和推理所涉及的步骤。\n\n\n\n训练数据由过去的观测值组成。 在大多数情况下，观测值包括观测到的事物的属性或特征，以及要训练模型来预测的事物的已知值（称为标签）。 在数学术语中，你经常会看到使用速记变量名称 x 引用的特征，以及使用 y 引用的标签。 通常，观测值由多个特征值组成，因此 x 实际上是一个向量（包含多个值的数组），如下所示：[x1,x2,x3,…]。 为了澄清这一点，让我们分析前面所述的示例：\n\n在冰淇淋销售场景中，我们的目标是训练一个可以根据天气预测冰淇淋销售数量的模型。 当天的天气测量值（温度、降雨量、风速等）是特征 (x)，每日售出的冰淇淋数量是标签 (y)。\n在医疗场景中，目标是根据患者的临床测量值预测患者是否有患糖尿病的风险。 患者的测量值（体重、血糖水平等）是特征 (x)，患糖尿病的可能性（例如，1 表示有风险，0 表示没有风险）是标签 (y)。\n在南极研究场景中，我们希望根据企鹅的物理属性来预测其物种。 企鹅的关键测量值（脚蹼的长度、喙的宽度等）是特征 (x)，物种（例如，0 表示阿德利企鹅，1 表示白眉企鹅，2 表示帽带企鹅）是标签 (y)。\n\n\n将对数据应用某种算法，以尝试确定特征与标签之间的关系，然后泛化这种关系，以便针对 x 执行计算来计算 y。 使用的具体算法取决于要解决的预测问题的类型（稍后会详细介绍），但基本原 则是尝试将一个函数拟合到数据，其中的特征值可用于计算标签\n\n算法的结果是一个模型，该模型将算法派生的计算封装为函数 - 我们称之为 f。 采用数学表示法：\n\n\ny &#x3D; f(x)\n\n完成训练阶段后，训练的模型可用于推理。 模型本质上是一个软件程序，可以封装训练过程生成的函数。 你可以输入一组特征值，并接收相应标签的预测结果作为输出。 由于模型的输出是函数计算的预测值而不是观测值，因此你经常会看到函数的输出显示为 ŷ（戏称为“y-hat”）\n\n第二部分机器学习类型机器学习有多种类型，必须根据尝试预测的内容应用适当的类型。 下图显示了常见机器学习类型的细目。\n\n\n监督式机器学习监督式机器学习是机器学习算法的一个通用术语，其中训练数据包括特征值和已知标签值。 监督式机器学习用于通过确定过去观测值中特征与标签之间的关系来训练模型，以便将来可以预测特征的未知标签。\n回归回归是监督式机器学习的一种形式，其中模型预测的标签是数值。 例如：\n\n给定一天销售的冰淇淋数量，基于温度、降雨量和风速。\n物业的销售价格，基于物业大小（以平方英尺为单位）、所含卧室数量及所在位置的社会经济指标。\n汽车燃油效率（以英里&#x2F;加仑为单位），基于发动机大小、重量、宽度、高度和长度。\n\n分类分类是监督式机器学习的一种形式，其中标签表示一个分类或类。 有两种常见的分类场景。\n二元分类在二元分类中，标签确定观察到的项是（或不是）特定类的实例。 换句话说，二元分类模型预测两个互斥结果中的一个。 例如：\n\n基于体重、年龄、血糖水平等临床指标，患者是否有患糖尿病的风险。\n基于收入、信用记录、年龄和其他因素，银行客户是否会拖欠贷款。\n基于人口统计属性和过去的购买情况，邮寄列表客户是否会对营销产品&#x2F;服务做出积极响应。\n\n在所有这些示例中，模型为单个可能类预测二进制 true&#x2F;false 或积极&#x2F;消极预测。\n多类分类\n多类分类扩展了二元分类，以预测表示多个可能类之一的标签。 例如，\n\n企鹅的物种（阿德利企鹅、巴布亚企鹅或帽带企鹅），基于身体测量。\n电影的流派（喜剧、恐怖、爱情、冒险或科幻），基于演员、导演和预算。\n\n在涉及一组已知多个类的场景中，多类分类用于预测互斥标签。 例如，一只企鹅不能同时是巴布亚企鹅和阿德利企鹅。 但是，还可以使用一些算法来训练多标签分类模型，其中对于单个观测值可能有多个有效标签。 例如，一部电影可能同时被归类为科幻和喜剧。\n非监督式机器学习非监督式机器学习涉及使用仅包含特征值且没有任何已知标签的数据来训练模型。 非监督式机器学习算法确定训练数据中观测值的特征之间的关系。\n群集&#x2F;聚类分析非监督式机器学习最常见的形式是聚类分析。 聚类分析算法基于观测值的特征识别观测值之间的相似性，并将它们分组到离散群集中。 例如：\n\n根据花的大小、叶数和花瓣数量，对类似的花进行分组。\n根据人口统计属性和购买行为，确定类似客户的组。\n\n在某些方面，聚类分析类似于多类分类；因为它将观侧值分类为离散组。 区别在于，使用分类时，你已经知道训练数据中的观测值所属的类；因此，该算法的工作原理是确定特征与已知分类标签之间的关系。 在聚类分析中，没有以前已知的分类标签，算法完全基于特征的相似性对数据观测值进行分组。\n在某些情况下，聚类分析用于确定在训练分类模型之前存在的类集。 例如，可以使用聚类分析将客户细分到多个组，然后对这些组进行分析，以识别不同的客户类并对其进行分类（高价值 - 低交易量、经常购买小额产品等）。 然后，可以使用分类来标记聚类分析结果中的观测值，并使用标记的数据来训练预测新客户可能属于哪个客户类别的分类模型。\n第三部分回归回归模型经过训练，基于包括特征和已知标签的训练数据来预测数值标签值。 训练回归模型（或者实际上，任何监督式机器学习模型）的过程涉及多次迭代，在这些迭代中，你使用适当的算法（通常带有一些参数化设置）来训练模型，评估模型的预测性能，并通过使用不同的算法和参数重复训练过程来优化模型，直到达到可接受的预测准确性级别。\n\n\n此图显示了监督式机器学习模型的训练过程的四个关键元素：\n\n拆分训练数据（随机）以创建用于训练模型的数据集，同时保留要用于验证已训练模型的一部分数据。\n使用算法以将训练数据拟合到模型。 对于回归模型，使用回归算法，例如线性回归。\n使用保留的验证数据，通过预测特征的标签来测试模型。\n将验证数据集中的已知实际标签与模型预测的标签进行比较。 然后，聚合预测的标签值和实际的标签值之间的差异以计算一个指标，该指标指示模型对验证数据的预测准确度。\n\n每次训练、验证和评估迭代后，可以使用不同的算法和参数重复该过程，直到达到可接受的评估指标。\n示例 - 回归让我们通过一个简化的示例来探索回归，在该示例中，我们将训练一个模型以基于单个特征值 (x) 预测数值标签 (y)。 大多数实际场景涉及多个特征值，这增加了一些复杂性；但原理是相同的。\n对于示例，让我们继续使用之前讨论过的冰淇淋销售场景。 对于特征，我们将考虑温度（假设该值是给定日期的最高温度），我们希望训练模型以预测的标签是当天售出的冰淇淋数量。 我们将从一些历史数据开始，其中包括每日温度 (x) 和冰淇淋销售额 (y) 的记录：\n\n\n\n温度 (x)\n冰淇淋销售额 (y)\n\n\n\n51\n1\n\n\n52\n0\n\n\n67\n14\n\n\n65\n14\n\n\n70\n23\n\n\n69\n20\n\n\n72\n23\n\n\n75\n26\n\n\n73\n22\n\n\n81\n30\n\n\n78\n26\n\n\n83\n36\n\n\n训练回归模型首先，我们将拆分数据，并使用其中一部分数据来训练模型。 下面是训练数据集：\n\n\n\n温度 (x)\n冰淇淋销售额 (y)\n\n\n\n51\n1\n\n\n65\n14\n\n\n69\n20\n\n\n72\n23\n\n\n75\n26\n\n\n81\n30\n\n\n若要深入了解这些 x 和 y 值如何相互关联，我们可以将它们绘制为沿两个轴的坐标，如下所示：\n\n\n现在，我们已准备好将算法应用于训练数据，并将其拟合到将运算应用于 x 以计算 y 的函数。 其中一种算法是线性回归，它的工作原理是派生一个函数，该函数通过 x 和 y 值的交点生成一条直线，同时最小化直线和绘制点之间的平均距离，如下所示：\n\n\n这条直线是函数的可视表示形式，其中直线的斜率描述了如何针对给定的 x 值计算 y 值。 这条直线在 50 处与 x 轴相交，因此当 x 为 50 时，y 为 0。 从绘图中的轴标记可以看出，直线倾斜，使得沿 x 轴每增加 5，沿 y 轴就会增加 5；因此当 x 为 55 时，y 为 5；当 x 为60时，y 为 10，依此类推。 若要针对给定的 x 值计算 y 值，函数只需减去 50；换句话说，函数可以如下表示：\nf(x) &#x3D; x-50\n可以使用此函数来预测任何给定温度下一天售出的冰淇淋数量。 例如，假设天气预报告诉我们，明天将是 77 度。 我们可以应用模型来计算 77-50，并预测我们明天将销售 27 个冰淇淋。\n但是我们的模型有多准确呢？\n评估回归模型为了验证模型并评估其预测效果，我们保留了一些已知标签 (y) 值的数据。 下面是我们保留的数据：\n\n\n\n温度 (x)\n冰淇淋销售额 (y)\n\n\n\n52\n0\n\n\n67\n14\n\n\n70\n23\n\n\n73\n22\n\n\n78\n26\n\n\n83\n36\n\n\n可以使用模型根据特征 (x) 值来预测此数据集中每个观测值的标签；然后，将预测的标签 (ŷ) 与已知的实际标签值 (y) 进行比较。\n使用前面训练的模型（该模型封装函数 f(x) &#x3D; x-50），可生成以下预测：\n\n\n\n温度 (x)\n实际销售额 (y)\n\n\n\n52\n0\n\n\n67\n14\n\n\n70\n23\n\n\n73\n22\n\n\n78\n26\n\n\n83\n36\n\n\n我们可以针对特征值绘制预测标签和实际标签，如下所示：\n\n\n预测标签由模型计算，因此它们位于函数线上，但是由函数计算的 ŷ 值与来自验证数据集的实际 y 值之间存在一些差异；这在绘图上表示为 ŷ 值和 y 值之间的线，显示预测值与实际值的差距。\n回归评估指标根据预测值和实际值之间的差异，可以计算用于评估回归模型的一些常见指标。\n平均绝对误差 (MAE)\n此示例中的方差指示每个预测错误的冰淇淋数量。 预测是高于还是低于实际值无关紧要（例如，-3 和 +3 都表示方差为 3）。 此指标被称为每个预测的绝对误差，并且可以被总结为整个验证集的平均绝对误差 (MAE)。\n在冰淇淋示例中，绝对误差（2、3、3、1、2 和 3）的平均值为 2.33。\n均方误差 (MSE)平均绝对误差指标同等地考虑预测标签和实际标签之间的所有差异。 然而，相比误差较少但较大的模型，一个始终误差较小的模型可能更可取。 生成“放大”较大误差的指标的一种方法是对单个误差求平方，并计算平方值的平均值。 此指标被称为均方误差 (MSE)。\n在我们的冰淇淋示例中，绝对值平方（4、9、9、1、4 和 9）的平均值为 6。\n均方根误差 (RMSE)均方误差有助于考虑误差的幅度，但是因为它对误差值进行平方，所以得到的指标不再代表标签测量的量。 换句话说，我们可以说模型的 MSE 为 6，但这并不能衡量它在被错误预测的冰淇淋数量方面的准确性；6 只是一个数字分数，表示验证预测中的错误级别。\n如果要根据冰淇淋的数量来衡量误差，我们需要计算 MSE 的平方根；不出所料，这生成了一个名为均方根误差的指标。 在本例中，为 √6，即 2.45（冰淇淋）。\n决定系数 (R2)到目前为止，所有指标都比较预测值与实际值之间的差异，以评估模型。 然而，在现实中，模型考虑到了冰淇淋日销售额中的一些自然随机差异。 在线性回归模型中，训练算法拟合一条直线，使函数和已知标签值之间的平均方差最小化。 决定系数（通常称为 R2 或 R 平方）是一种指标，用于测量验证结果中可由模型解释的方差比例，而不是验证数据的某些异常方面（例如，由于当地节日，某一天的冰淇淋销售量非常不寻常）。\nR2 的计算比前面的指标更复杂。 它将预测标签和实际标签之间的平方差之和与实际标签值和实际标签值的平均值之间的平方差之和进行比较，如下所示：\nR2 &#x3D; 1- ∑(y-ŷ)2 ÷ ∑(y-ȳ)2\n如果这看起来很复杂，不要太担心；大多数机器学习工具都可以为你计算指标。 重要的一点是，结果是一个介于 0 和 1 之间的值，该值描述了模型所解释的方差的比例。 简单来说，此值越接近 1，模型就越拟合验证数据。 对于冰淇淋回归模型，根据验证数据计算的 R2 为 0.95。\n第四部分二元分类分类与回归一样，是一种受监督的机器学习技术，因此遵循相同的适用于训练、验证和评估模型的迭代过程。 用于训练分类模型的算法不是像回归模型那样计算数值，而是计算类分配的概率值以及用于评估模型性能的评估指标，将预测类与实际类进行比较。\n二元分类算法用于训练模型，该模型可预测单个类的两个可能标签之一。 本质上是预测 true 或 false。 在大多数实际方案中，用于训练和验证模型的数据观测值包含多个特征 (x) 值和一个为 1 或 0 的 y 值。\n示例 - 二元分类为了了解二元分类的工作原理，我们来看一个简化的示例，该示例使用单个特征 (x) 来预测标签 y 是 1 还是 0。 在此示例中，我们将使用患者的血糖水平来预测患者是否患有糖尿病。 下面是用于训练模型的数据：\n\n\n\n血糖 (x)\n糖尿病？ (y)\n\n\n\n67\n0\n\n\n103\n1\n\n\n114\n1\n\n\n72\n0\n\n\n116\n1\n\n\n65\n0\n\n\n训练二元分类模型为了训练模型，我们将使用一种算法将训练数据拟合为一个函数，该函数计算类标签为 true（换句话说，患者有糖尿病）的概率。 概率以某个 0.0 到 1.0 之间的值来度量，使得所有可能的类的总概率为 1.0。 例如，如果一名患者患糖尿病的概率为 0.7，那么该患者未患糖尿病的相应概率为 0.3。\n有许多可用于二元分类的算法，例如逻辑回归，它会导出值在 0.0 到 1.0 之间的 sigmoid（S 形）函数，如下所示：\n\n\n\n尽管名称如此，但在机器学习中，逻辑回归用于分类，而不是用于回归。 重点是它生成的函数的逻辑性质，该函数描述了下限值和上限值（用于二元分类时为 0.0 和 1.0）之间的 S 形曲线。\n\n该算法生成的函数描述了 x 为给定值时 y 为 true (y&#x3D;1) 的概率。 从数学上来说，可以这样表达该函数：\nf(x) &#x3D; P(y&#x3D;1 | x)\n就训练数据中六个观测值中的三个来说，我们知道 y 肯定为 true，因此就这些观测值来说，y&#x3D;1 的概率为 1.0；就其他三个来说，我们知道 y 肯定为 false，因此 y&#x3D;1 的概率为 0.0。 S 形曲线描绘了概率分布情况，因此在曲线上标出 x 的值就可以确定 y 为 1 的相应概率。\n该图还包含一条水平线，指示基于此函数的模型将预测 true (1) 或 false (0) 的阈值。 阈值位于 y (P(y) &#x3D; 0.5) 的中间点。 对于此点或高于此点的任何值，模型会预测 true (1)；而对于低于此点的任何值，模型会预测 false (0)。 例如，对于血糖水平为 90 的患者，该函数将得出的概率值为 0.9。 由于 0.9 高于阈值 0.5，因此模型会预测 true (1) - 换句话说，预测患者患有糖尿病。\n评估二元分类模型与回归一样，在训练二元分类模型时，我们会保留一个随机数据子集来验证训练后的模型。 假设我们保留以下数据来验证糖尿病分类器：\n\n\n\n血糖 (x)\n糖尿病？ (y)\n\n\n\n66\n0\n\n\n107\n1\n\n\n112\n1\n\n\n71\n0\n\n\n87\n1\n\n\n89\n1\n\n\n将我们之前派生的逻辑函数应用于 x 值会生成下图。\n\n\n模型为每个观测值生成预测标签 1 或 0，具体取决于函数计算出的概率是高于阈值还是低于阈值。 然后，我们可以将预测的类标签 (ŷ) 与实际的类标签 (y) 进行比较，如下所示：\n\n\n\n血糖 (x)\n实际的糖尿病诊断 (y)\n预测的糖尿病诊断 (ŷ)\n\n\n\n66\n0\n0\n\n\n107\n1\n1\n\n\n112\n1\n1\n\n\n71\n0\n0\n\n\n87\n1\n0\n\n\n89\n1\n1\n\n\n二元分类评估指标计算二元分类模型的评估指标的第一步通常是为每个可能的类标签创建正确预测和错误预测的数量矩阵：\n\n\n此可视化效果称为混淆矩阵，它显示预测总计，其中：\n\nŷ&#x3D;0 且 y&#x3D;0：真阴性 (TN)\nŷ&#x3D;1 且 y&#x3D;0：假阳性 (FP)\nŷ&#x3D;0 且 y&#x3D;1：假阴性 (FN)\nŷ&#x3D;1 且 y&#x3D;1：真阳性 (TP)\n\n混淆矩阵的排列是这样的：正确 (true) 预测显示在从左上角到右下角的对角线上。 通常情况下，颜色强度用于指示每个单元格中的预测数量，因此快速浏览一下预测良好的模型应该就会看出深阴影对角线趋势。\n精确度可以根据混淆矩阵计算出的最简单指标是准确度 - 模型正确预测的比例。 准确度的计算方式如下：\n(TN+TP) ÷ (TN+FN+FP+TP)\n在我们的糖尿病示例中，计算如下：\n(2+3) ÷ (2+1+0+3)\n&#x3D; 5 ÷ 6\n&#x3D; 0.83\n因此，就我们的验证数据来说，糖尿病分类模型在 83% 的情况下产生正确的预测。\n准确度一开始似乎是评估模型的一个很好的指标，但请考虑这一点。 假设 11% 的人口患有糖尿病。 可以创建一个始终预测 0 的模型，即使在没有真正尝试通过评估患者的特征来区分患者的情况下，其准确率仍可达到 89%。 我们真正需要的是更深入地了解模型在预测 1（代表阳性病例）和 0（代表阴性病例）时的表现。\n召回率召回率是度量此模型正确识别的阳性病例比例的指标。 换句话说，与确实患有糖尿病的患者人数相比，此模型预测有多少人患有糖尿病？\n召回率的公式为：\nTP ÷ (TP+FN)\n就我们的糖尿病示例来说：\n3 ÷ (3+1)\n&#x3D; 3 ÷ 4\n&#x3D; 0.75\n因此，我们的模型正确地将 75% 的糖尿病患者识别为糖尿病患者。\n精度精准率是与召回率类似的指标，但度量的是预测为阳性病例且真实标签实际上也为阳性的比例。 换句话说，在模型预测患有糖尿病的患者中，实际患有糖尿病的患者的比例是多少？\n精准率公式为：\nTP ÷ (TP+FP)\n就我们的糖尿病示例来说：\n3 ÷ (3+0)\n&#x3D; 3 ÷ 3\n&#x3D; 1.0\n因此，在我们的模型预测的患有糖尿病的患者中，100% 的人确实患有糖尿病。\nF1 分数F1 分数是一个结合了召回率和精准率的总体指标。 F1 分数的公式为：\n(2 x 精准率 x 召回率) ÷ (精准率 + 召回率)\n就我们的糖尿病示例来说：\n(2 x 1.0 x 0.75) ÷ (1.0 + 0.75)\n&#x3D; 1.5 ÷ 1.75\n&#x3D; 0.86\n曲线下面积 (AUC)召回率的另一个名称是真阳性率 (TPR)。此外还有一个称为假阳性率 (FPR) 的等效指标，其计算公式为 FP÷(FP+TN)。 我们已经知道，在使用阈值 0.5 时，我们的模型的 TPR 为 0.75。我们可以使用 FPR 的公式计算出 0÷2 的值为 0。\n当然，如果我们更改模型预测 true (1) 的阈值，则会影响阳性和阴性预测的数量，因此会更改 TPR 和 FPR 指标。 这些指标通常用于通过绘制接收方操作特征 (ROC) 曲线来评估模型，该曲线会比较 0.0 到 1.0 之间的每个可能阈值的 TPR 和 FPR：\n\n\n完美模型的 ROC 曲线会沿左侧的 TPR 轴直线上升，然后穿过顶部的 FPR 轴。 由于曲线的绘图面积为 1x1，因此该完美曲线下的面积将为 1.0（这意味着模型始终是正确的）。 相比之下，从左下角到右上角的对角线表示通过随机猜测二进制标签获得的结果；产生的曲线下面积为 0.5。 换句话说，给定两个可能的类标签，你可以合理预期猜对的概率为 50%。\n就我们的糖尿病模型来说，会生成上面的曲线，曲线下面积 (AUC) 指标为 0.875。 由于 AUC 高于 0.5，因此我们可以得出结论：该模型在预测患者是否患有糖尿病方面比随机猜测的表现更好。\n","categories":["ai"]},{"title":"Flask Overview","url":"/2025/01/07/ai-plateform-flask/","content":"Flask OverviewPython InstallPlease install the python on your computer based on Python.If the system has some environmental path error when using the python order, please read How to add to the PYTHONPATH in Windows.\nVirtual environmentsUse a virtual environment to manage the dependencies for your project, both in development and in production.\nWhat problem does a virtual environment solve? The more Python projects you have, the more likely it is that you need to work with different versions of Python libraries, or even Python itself. Newer versions of libraries for one project can break compatibility in another project.\nVirtual environments are independent groups of Python libraries, one for each project. Packages installed for one project will not affect other projects or the operating system’s packages.\n\nCreate an environment.\n\nmkdir myprojectcd myprojectpy -3 -m venv .venv\n\n\nActive the environment.\n\n.venv\\Scripts\\activate\n\nInstall Flaskpip install Flask\n\nQuickstartA Minimal Applicationfrom flask import Flaskapp = Flask(__name__)@app.route(&quot;/&quot;)def hello_world():    return &quot;&lt;p&gt;Hello, World!&lt;/p&gt;&quot;\n\nTo run the application, use the flask command or python -m flask. You need to tell the Flask where your application is with the --app option.\nflask --app hello run\n\n\n\nAs a shortcut, if the file is named app.py or wsgi.py, you don’t have to use –app. See Command Line Interface for more details.\n\nDebug ModeTo enable debug mode, use the --debug option.\nflask --app hello run --debug\n\nHTML EscapingWhen returning HTML (the default response type in Flask), any user-provided values rendered in the output must be escaped to protect from injection attacks. HTML templates rendered with Jinja, introduced later, will do this automatically.\nescape(), shown here, can be used manually. It is omitted in most examples for brevity, but you should always be aware of how you’re using untrusted data.\nfrom flask import Flaskfrom markupsafe import escapeapp = Flask(__name__)@app.route(&quot;/&quot;)def hello_world():    return &quot;&lt;p&gt;Hello, World!&lt;/p&gt;&quot;@app.route(&quot;/&lt;name&gt;&quot;)def hello(name):    return f&quot;Hello, &#123;escape(name)&#125;!&quot;;\n\nRoutingModern web applications use meaningful URLs to help users. Users are more likely to like a page and come back if the page uses a meaningful URL they can remember and use to directly visit a page.\nUse the route() decorator to bind a function to a URL.\n@app.route(&#x27;/&#x27;)def index():    return &#x27;Index Page&#x27;@app.route(&#x27;/hello&#x27;)def hello():    return &#x27;Hello, World&#x27;\n\nVariable RulesYou can add variable sections to a URL by marking sections with &lt;variable_name&gt;. Your function then receives the &lt;variable_name&gt; as a keyword argument. Optionally, you can use a converter to specify the type of the argument like &lt;converter:variable_name&gt;.\nfrom markupsafe import escape@app.route(&#x27;/user/&lt;username&gt;&#x27;)def show_user_profile(username):    # show the user profile for that user    return f&#x27;User &#123;escape(username)&#125;&#x27;@app.route(&#x27;/post/&lt;int:post_id&gt;&#x27;)def show_post(post_id):    # show the post with the given id, the id is an integer    return f&#x27;Post &#123;post_id&#125;&#x27;@app.route(&#x27;/path/&lt;path:subpath&gt;&#x27;)def show_subpath(subpath):    # show the subpath after /path/    return f&#x27;Subpath &#123;escape(subpath)&#125;&#x27;\n\n\n\n\ntype\ndescription\n\n\n\nstring\n(default) accepts any text without a slash\n\n\nint\naccepts positive integers\n\n\nfloat\naccepts positive floating point values\n\n\npath\nlike string but also accepts slashes\n\n\nuuid\naccepts UUID strings\n\n\nUnique URLs &#x2F; Redirection BehaviorThe following two rules differ in their use of a trailing slash.\n@app.route(&#x27;/projects/&#x27;)def projects():    return &#x27;The project page&#x27;@app.route(&#x27;/about&#x27;)def about():    return &#x27;The about page&#x27;\n\nThe canonical URL for the projects endpoint has a trailing slash. It’s similar to a folder in a file system. If you access the URL without a trailing slash (&#x2F;projects), Flask redirects you to the canonical URL with the trailing slash (&#x2F;projects&#x2F;).\nThe canonical URL for the about endpoint does not have a trailing slash. It’s similar to the pathname of a file. Accessing the URL with a trailing slash (&#x2F;about&#x2F;) produces a 404 “Not Found” error. This helps keep URLs unique for these resources, which helps search engines avoid indexing the same page twice.\nHTTP MethodsWeb applications use different HTTP methods when accessing URLs. You should familiarize yourself with the HTTP methods as you work with Flask. By default, a route only answers to GET requests. You can use the methods argument of the route() decorator to handle different HTTP methods.\nfrom flask import request@app.route(&#x27;/login&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def login():    if request.method == &#x27;POST&#x27;:        return do_the_login()    else:        return show_the_login_form()\n\nThe example above keeps all methods for the route within one function, which can be useful if each part uses some common data.\nYou can also separate views for different methods into different functions. Flask provides a shortcut for decorating such routes with get(), post(), etc. for each common HTTP method.\n@app.get(&#x27;/login&#x27;)def login_get():    return show_the_login_form()@app.post(&#x27;/login&#x27;)def login_post():    return do_the_login()\n\nIf GET is present, Flask automatically adds support for the HEAD method and handles HEAD requests according to the HTTP RFC. Likewise, OPTIONS is automatically implemented for you.\nStatic FilesDynamic web applications also need static files. That’s usually where the CSS and JavaScript files are coming from. Ideally your web server is configured to serve them for you, but during development Flask can do that as well. Just create a folder called static in your package or next to your module and it will be available at &#x2F;static on the application.\nTo generate URLs for static files, use the special ‘static’ endpoint name:\nurl_for(&#x27;static&#x27;, filename=&#x27;style.css&#x27;)\n\nThe file has to be stored on the filesystem as static&#x2F;style.css.\nRendering TemplatesGenerating HTML from within Python is not fun, and actually pretty cumbersome because you have to do the HTML escaping on your own to keep the application secure. Because of that Flask configures the Jinja2 template engine for you automatically.\nTemplates can be used to generate any type of text file. For web applications, you’ll primarily be generating HTML pages, but you can also generate markdown, plain text for emails, and anything else.\nFor a reference to HTML, CSS, and other web APIs, use the MDN Web Docs.\nTo render a template you can use the render_template() method. All you have to do is provide the name of the template and the variables you want to pass to the template engine as keyword arguments. Here’s a simple example of how to render a template:\nfrom flask import render_template@app.route(&#x27;/hello/&#x27;)@app.route(&#x27;/hello/&lt;name&gt;&#x27;)def hello(name=None):    return render_template(&#x27;hello.html&#x27;, person=name)Flask will look for templates in the templates folder. So if your application is a module, this folder is next to that module, if it’s a package it’s actually inside your package:\n\nCase 1: a module:\n/application.py/templates    /hello.html\n\nCase 2: a package:\n/application    /__init__.py    /templates        /hello.html\n\nFor templates you can use the full power of Jinja2 templates. Head over to the official Jinja2 Template Documentation for more information.\nHere is an example template:\n&lt;!doctype html&gt;&lt;title&gt;Hello from Flask&lt;/title&gt;&#123;% if person %&#125;  &lt;h1&gt;Hello &#123;&#123; person &#125;&#125;!&lt;/h1&gt;&#123;% else %&#125;  &lt;h1&gt;Hello, World!&lt;/h1&gt;&#123;% endif %&#125;\n\nAccessing Request DataFor web applications it’s crucial to react to the data a client sends to the server. In Flask this information is provided by the global request object. If you have some experience with Python you might be wondering how that object can be global and how Flask manages to still be threadsafe. The answer is context locals:\nSo what does this mean to you? Basically you can completely ignore that this is the case unless you are doing something like unit testing. You will notice that code which depends on a request object will suddenly break because there is no request object. The solution is creating a request object yourself and binding it to the context. The easiest solution for unit testing is to use the test_request_context() context manager. In combination with the with statement it will bind a test request so that you can interact with it. Here is an example:\nfrom flask import requestwith app.test_request_context(&#x27;/hello&#x27;, method=&#x27;POST&#x27;):    # now you can do something with the request until the    # end of the with block, such as basic assertions:    assert request.path == &#x27;/hello&#x27;    assert request.method == &#x27;POST&#x27;","categories":["flask"]},{"title":"Cache","url":"/2024/12/22/commerce-cache/","content":"POS 前后端通信通常需要使用 extension properties；extension properties 存在于 Cart、CartLine、SalesTransaction 和 SalesLine 等；但某些场景，无法编辑 extension properties，所以无法通信；可以按照以下 Cache 构建新的通信机制；（谨慎使用，影响性能）\n\n\nCache.cs 代码示例using Microsoft.Extensions.Caching.Memory;using System;namespace LMS.Cache&#123;    public class LMSCache    &#123;        private static readonly Lazy&lt;MemoryCache&gt; lazy = new Lazy&lt;MemoryCache&gt;(()            =&gt; new MemoryCache(new MemoryCacheOptions()));        private static MemoryCache cache        &#123;            get            &#123;                return lazy.Value;            &#125;        &#125;        public T Get&lt;T&gt;(string key)        &#123;            if (!cache.TryGetValue&lt;T&gt;(key, out T cacheItem))            &#123;                return default;            &#125;            else            &#123;                return cacheItem;            &#125;        &#125;        public void Put&lt;T&gt;(string key, T value, int cacheLifeInSeconds = 500)        &#123;            if (value == null)            &#123;                if (cache.Get(key) != null)                &#123;                    cache.Remove(key);                &#125;            &#125;            else            &#123;                cache.Set&lt;T&gt;(key, value, DateTimeOffset.Now.AddSeconds(cacheLifeInSeconds));            &#125;        &#125;    &#125;&#125;\n\n使用示例(new LMSCache()).Get&lt;string&gt;(key); // Get the value by key(new LMSCache()).Put&lt;string, string&gt;(key, value); // Put the key value mapping","categories":["commerce"]},{"title":"Document Routing Agent in D365 F&O","url":"/2025/07/08/d365-documentroutingconfiguration/","content":"\nReprinted from: https://mohitrampal.com/2023/03/20/document-routing-agent-in-d365-fo/\n\n\nYou can also watch video: https://www.youtube.com/watch?v=oG6n2PA-Phs\n\n\nChinese version: https://www.cnblogs.com/lingdanglfw/p/14141545.html\n\n\nOfficial documentation: https://learn.microsoft.com/en-us/dynamics365/fin-ops-core/dev-itpro/analytics/er-design-zpl-labels\n\n\nZPL View: https://labelary.com/viewer.html\n\nThe Document Routing Agent (DRA) is an application that resides on the Customer’s network, to act as a bridge between the internet-hosted Dynamics 365 (D365 F&amp;O) system and Customer’s network printers.\n\n\nDRA tool is Supported on Windows 8.1, Windows 10, Microsoft Windows Server 2012 R2, Microsoft Windows Server 2016, or Microsoft Windows Server 2019.\nDRA run as either a desktop application or a Microsoft Windows service.\nDRA as a Service can be configured to start automatically after a computer restart, so no user intervention is required. However, When the Document Routing Agent runs as a Windows service, document reports, such as checks, that require custom margins can’t be printed directly to network printers. Instead, the Document Routing Agent automatically routes those documents to a target folder.\nDRA as a desktop application uses Adobe Reader to spool the document to the shared printer device chosen in finance and operations. Microsoft recommends installing the Document Routing Agent in several places to manage situations when documents with custom margins need to be printed. The printers for those documents should thus only be installed on Document Routing Agents that will operate in desktop application mode. As an alternative, you can pick up the files in the target directory and guide them in the right direction using a post-execution process.\nSteps to Install &amp; Configure DRASign in to D365 F&amp;O environment which you want to configure in the DRA tool.\n\nGo to Organization Administration–&gt;Setup–&gt;Network Printers\nClick on Download Document Routing Agent Installer.\n\n\n\n\nEnsure that you are logged in as Admin user. Run the downloaded file and complete the setup.\nOpen the DRA tool and sign in with Admin account.\n\n\n\n\nClick on Settings Button and enter values in all the fields.\n\n\n\n\nIf Run as Windows Service checkbox is checked, then DRA will run as a Service. To run as service, window service should be set up and running.\n\nRight click on the highlighted Service and click on Properties.\n\n\nClick on Log On tab and add your Admin&#x2F;Service account.\n\n\nPlease note that step 6 is not required if running as an Application (Run as a window service checkbox is unchecked).\n\nStart the service and go back to step 5 and Click on Printers.\n\nOnly printers which are registered will be visible in D365 F&amp;O.\n\n\n\nAfter registering a printer, go to D365 F&amp;O (Organization Administration–&gt;Setup–&gt;Network Printers) and activate the printer.\n\n\n\n\nNow, you can test it in your reports by using Network Printer as shown below (after printing to screen), or setting up the print management.\n\n\n\nI had a requirement to test multiple network printers based on specific values, like if department is A the document should route to PrinterA, if department is B, it should go to PrinterB etc. This configuration was done in print management of report and I tested with dummy Printers and OneNote.\nYou can setup a dummy printer by going to Printers &amp; Scanners.\n\nClick on Add a Printer or Scanner button.\n\n\n\n\nClick on ‘The printer that I want isn’t listed.’\n\n\n\n\nSelect last option as below screenshot and click Next.\n\n\n\n\nSelect Nul port and click Next.\n\n\n\n\nSelect Microsoft Print to PDF and click Next\n\n\n\n\n\n\nSpecify printer name and click Next.\n\n\n\n\n\n\nClick on Open Queue of Printer and Pause Printing.\n\n\n\n\nAs mentioned earlier, you need to register the printer.\n\n\n\n\nAfter registering the printer, it will be visible in D365 F&amp;O. Activate the printer.\n\n\n\n\n\n\nAs you can see, After report is printed on screen, I can select my new printer.\n\n\n\n\n\n\nThe document will be visible in print queue.\n\n\n\nNote\nDRA is legal entity specific, so you have to setup the printers in all required legal entities.\nIf you already have DRA tool, you might get below error for different versions.To resolve this, you have to uninstall the DRA and install again.\n\n","categories":["d365"]},{"title":"How to Print the Amount Based on the Language Id","url":"/2024/12/23/commerce-use-languageId/","content":"How to get the Language Idstring languageText = string.Empty;if (request.RequestContext.LanguageId != null &amp;&amp; request.RequestContext.LanguageId != &quot;&quot;) // Get the LanguageId from request context&#123;    languageText = request.RequestContext.LanguageId;&#125;else&#123;    languageText = &quot;en-us&quot;;&#125;CultureInfo culture = new CultureInfo(languageText); // Get the culture based on LanguageId\n\nFormat the amount based on cultureThe decimal.ToString() included two parameters, for example:\ndl.EffectiveAmount.ToString(&quot;C2&quot;, culture); // The first parameter means the currency code should be something, the second parameter means the amount value should be format based on some culture rules.​","categories":["commerce"]},{"title":"Flask Turorial 2","url":"/2025/01/09/flask-tutorial-2/","content":"Flask Turorial 2Blueprints and Views一个 view 函数是你写来响应请求的代码。Flask使用模式将传入的请求URL与应该处理它的视图进行匹配。视图返回数据，Flask将这些数据转换为输出响应。Flask也可以走另一个方向，根据视图的名称和参数生成一个URL。\nCreate a BlueprintBlueprint是一种组织一组相关视图和其他代码的方法。它们不是直接在应用程序中注册视图和其他代码，而是在蓝图中注册。然后，当蓝图在工厂功能中可用时，将其注册到应用程序中。\nFlaskr将有两个蓝图，一个用于身份验证功能，一个用于博客帖子功能。每个蓝图的代码将放在一个单独的模块中。由于博客需要了解身份验证，因此您将首先编写身份验证。\n\nflaskr&#x2F;auth.py\n\nimport functoolsfrom flask import (    Blueprint, flash, g, redirect, render_template, request, session, url_for)from werkzeug.security import check_password_hash, generate_password_hashfrom flaskr.db import get_dbbp = Blueprint(&#x27;auth&#x27;, __name__, url_prefix = &#x27;/auth&#x27;)\n\n这将创建一个名为“auth”的蓝图。与应用程序对象一样，蓝图需要知道它的定义位置，因此__name__作为第二个参数传递。url_prefix将被添加到与蓝图关联的所有url之前。\n使用app.register_blueprint（）从工厂导入并注册蓝图。在返回应用程序之前，将新代码放在工厂函数的末尾。\n\nflaskr&#x2F;init.py\n\n# Register the auth blueprintfrom . import authapp.register_blueprint(auth.bp)\n\n身份验证蓝图将具有注册新用户以及登录和注销的视图。\nThe First View: Register当用户访问&#x2F;auth&#x2F;register URL时，注册视图将返回带有表单的HTML供他们填写。当他们提交表单时，它将验证他们的输入，并再次显示带有错误消息的表单，或者创建新用户并转到登录页面。\n现在您只需编写视图代码。在下一页中，您将编写模板来生成HTML表单。\n\nflaskr&#x2F;auth.py\n\n@bp.route(&#x27;/register&#x27;, methods=(&#x27;GET&#x27;, &#x27;POST&#x27;))def register():    if request.method == &#x27;POST&#x27;:        username = request.form[&#x27;username&#x27;]        password = request.form[&#x27;password&#x27;]        db = get_db()        error = None        if not username:            error = &#x27;Username is required&#x27;        elif not password            error = &#x27;Password is required&#x27;        if error is None:            try:                db.execute(                    &quot;INSERT INTO user (username, password) VALUES (?, ?)&quot;,                    (username, generate_password_hash(password))                )                db.commit()            except db.IntegrityError:                error = f&quot;User &#123;username&#125; is already registered&quot;            else                return redirect(url_for(&#x27;auth.login&#x27;))                    flash(error)    return render_template(&#x27;auth/register.html&#x27;)\n\n以下是代码解析：\n\n@bp。route将URL /register与注册视图函数关联起来。当Flask接收到对/auth/register的请求时，它将调用register视图并使用返回值作为响应。\n\n如果用户提交了表单，request.method 将是POST。在本例中，开始验证输入。\n\nrequest.form是一种特殊类型的映射提交表单键和值的字典。用户将输入他们的用户名和密码。\n\n验证 username 和 password 不为空\n\n如果验证成功，插入新的用户数据到数据库  \n\ndb.execute 使用?用于任何用户输入的占位符，以及用于替换占位符的值元组。数据库库将负责转义这些值，这样您就不会受到SQL注入攻击。\n为了安全起见，永远不要将密码直接存储在数据库中。相反，使用generate_password_hash（）安全地对密码进行散列，并存储该散列。由于该查询修改了数据，因此需要在之后调用db.commit（）来保存更改。\n如果用户名已经存在，则会发生sqlite3.IntegrityError，这应该作为另一个验证错误显示给用户。\n\n\n存储用户之后，它们被重定向到登录页面。url_for（）根据登录视图的名称为其生成URL。这比直接编写URL更可取，因为它允许您稍后更改URL，而无需更改链接到它的所有代码。redirect（）生成对生成的URL的重定向响应。\n\n如果验证失败，错误将显示给用户。Flash（）存储可以在呈现模板时检索的消息。\n\n当用户最初导航到认证&#x2F;注册时，或者出现验证错误时，应该显示一个包含注册表单的HTML页面。render_template（）将呈现一个包含HTML的模板，该模板将在本教程的下一步中编写。\n\n\nLogin@bp.route(&#x27;/login&#x27;, methods = (&#x27;GET&#x27;, &#x27;POST&#x27;))def login():    if request.method == &#x27;POST&#x27;:        username = request.form[&#x27;username&#x27;]        password = request.form[&#x27;password&#x27;]        db = get_db()        error = None        user = db.execute(            &#x27;SELECT * FROM user WHERE username = ?&#x27;, (username)        ).fetchone()        if user is None:            error = &#x27;Incorrect username.&#x27;        elif not check_password_hash(user[&#x27;password&#x27;, password]):            error = &#x27;Incorrect password.&#x27;                if error is None:            session.clear()            session[&#x27;user_id&#x27;] = user[&#x27;id&#x27;]            return redirect(url_for(&#x27;index&#x27;))                flash(error)    return render_template(&#x27;auth/login.html&#x27;)\n\nThere are a few differences from the register view:\n\nThe user is queried first and stored in a variable for later use. fetchone() returns one row from the query. If the query returned no results, it returns None. Later, fetchall() will be used, which returns a list of all results.\n\ncheck_password_hash() hashes the submitted password in the same way as the stored hash and securely compares them. If they match, the password is valid.\n\nsession is a dict that stores data across requests. When validation succeeds, the user’s id is stored in a new session. The data is stored in a cookie that is sent to the browser, and the browser then sends it back with subsequent requests. Flask securely signs the data so that it can’t be tampered with.\n\n\n@bp.before_app_requestdef load_logged_in_user():    user_id = session.get(&#x27;user_id&#x27;)    if user_id is None:        g.user = None    else:        g.user = get_db().execute(            &#x27;SELECT * FROM user WHERE id = ?&#x27;, (user_id)        ).fetchone()\n\nbp.before_app_request（）注册一个在视图函数之前运行的函数，无论请求的URL是什么。Load_logged_in_user检查用户id是否存储在会话中，并从数据库中获取该用户的数据，将其存储在g.user上，该数据将持续请求的长度。如果没有用户id，或者用户id不存在，g.user将为None。\nLogout要注销，需要从会话中删除用户id。那么load_logged_in_user将不会在后续请求中加载用户。\n@bp.route(&#x27;/logout&#x27;)def logout():    session.clear()    return redirect(url_for(&#x27;index&#x27;))\n\nRequire Authentication in Other Views创建、编辑和删除博客文章需要用户登录。可以使用装饰器来检查它应用到的每个视图。\ndef login_required(view):    @functools.wraps(view)    def wrapped_view(**kwargs):        if g.user is None:            return redirect(url_for(&#x27;auth.login&#x27;))            return wrapped_view\n\n这个装饰器返回一个新的视图函数，该函数包装了它所应用的原始视图。新函数检查用户是否已加载，否则将重定向到登录页面。如果用户被加载，则调用原始视图并正常继续。您将在编写博客视图时使用该装饰器。\nEndpoints and URLsurl_for（）函数根据名称和参数生成视图的URL。与视图关联的名称也称为端点，默认情况下，它与视图函数的名称相同。\n例如，在教程前面添加到应用程序工厂的hello（）视图的名称为‘hello’，可以使用url_for（’hello’）链接到它。如果它接受一个参数，稍后您将看到，它将被链接到使用url_for（’hello’, who&#x3D;’World’）。\n当使用蓝图时，蓝图的名称被附加到函数的名称之前，因此您在上面编写的登录函数的端点是‘auth ’。Login ‘，因为您将它添加到’auth’蓝图中。\nTemplates模板是包含静态数据和动态数据占位符的文件。使用特定的数据呈现模板以生成最终文档。Flask使用Jinja模板库来呈现模板。\n在您的应用程序中，您将使用模板来呈现将显示在用户浏览器中的HTML。在Flask中，Jinja被配置为自动转义HTML模板中呈现的任何数据。这意味着呈现用户输入是安全的；他们输入的任何可能扰乱HTML的字符，如&lt;and&gt;，都将被转义为安全值，这些值在浏览器中看起来是一样的，但不会产生不必要的效果。\nJinja的外观和行为都很像Python。使用特殊分隔符将Jinja语法与模板中的静态数据区分开来。&#123;&#123;and&#125;&#125;之间的任何内容都是将输出到最终文档的表达式。&#123;%and%&#125;表示控制流语句，如if和for。与Python不同，块由开始和结束标记而不是缩进表示，因为块中的静态文本可能会改变缩进。\nThe Base Layout&lt;!doctype html&gt;&lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125; - Flaskr&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;&#123; url_for(&#x27;static&#x27;, filename=&#x27;style.css&#x27;) &#125;&#125;&quot;&gt;&lt;nav&gt;  &lt;h1&gt;Flaskr&lt;/h1&gt;  &lt;ul&gt;    &#123;% if g.user %&#125;      &lt;li&gt;&lt;span&gt;&#123;&#123; g.user[&#x27;username&#x27;] &#125;&#125;&lt;/span&gt;      &lt;li&gt;&lt;a href=&quot;&#123;&#123; url_for(&#x27;auth.logout&#x27;) &#125;&#125;&quot;&gt;Log Out&lt;/a&gt;    &#123;% else %&#125;      &lt;li&gt;&lt;a href=&quot;&#123;&#123; url_for(&#x27;auth.register&#x27;) &#125;&#125;&quot;&gt;Register&lt;/a&gt;      &lt;li&gt;&lt;a href=&quot;&#123;&#123; url_for(&#x27;auth.login&#x27;) &#125;&#125;&quot;&gt;Log In&lt;/a&gt;    &#123;% endif %&#125;  &lt;/ul&gt;&lt;/nav&gt;&lt;section class=&quot;content&quot;&gt;  &lt;header&gt;    &#123;% block header %&#125;&#123;% endblock %&#125;  &lt;/header&gt;  &#123;% for message in get_flashed_messages() %&#125;    &lt;div class=&quot;flash&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;  &#123;% endfor %&#125;  &#123;% block content %&#125;&#123;% endblock %&#125;&lt;/section&gt;\n\nRegister&#123;% extends &#x27;base.html&#x27; %&#125;&#123;% block header %&#125;  &lt;h1&gt;&#123;% block title %&#125;Register&#123;% endblock %&#125;&lt;/h1&gt;&#123;% endblock %&#125;&#123;% block content %&#125;  &lt;form method=&quot;post&quot;&gt;    &lt;label for=&quot;username&quot;&gt;Username&lt;/label&gt;    &lt;input name=&quot;username&quot; id=&quot;username&quot; required&gt;    &lt;label for=&quot;password&quot;&gt;Password&lt;/label&gt;    &lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; required&gt;    &lt;input type=&quot;submit&quot; value=&quot;Register&quot;&gt;  &lt;/form&gt;&#123;% endblock %&#125;\n\nLog In&#123;% extends &#x27;base.html&#x27; %&#125;&#123;% block header %&#125;  &lt;h1&gt;&#123;% block title %&#125;Log In&#123;% endblock %&#125;&lt;/h1&gt;&#123;% endblock %&#125;&#123;% block content %&#125;  &lt;form method=&quot;post&quot;&gt;    &lt;label for=&quot;username&quot;&gt;Username&lt;/label&gt;    &lt;input name=&quot;username&quot; id=&quot;username&quot; required&gt;    &lt;label for=&quot;password&quot;&gt;Password&lt;/label&gt;    &lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; required&gt;    &lt;input type=&quot;submit&quot; value=&quot;Log In&quot;&gt;  &lt;/form&gt;&#123;% endblock %&#125;","categories":["flask"]},{"title":"Difference Between Transfer Journal and Transfer Order D365 F&O","url":"/2025/07/08/d365-transferjournalandtransferorder/","content":"In Dynamics 365 Finance and Operations (D365 F&amp;O), knowing the difference between a transfer journal and a Transfer Order is crucial when handling inventories. Although they seem to be related, these two features serve separate purposes and meet different needs.\nThis write-up explores the nuances of transfer journals and transfer orders, explaining their differences and uses inside D365 F&amp;O.\nOverview of Dynamics 365 Finance and OperationsDesigned to maximize business processes, Dynamics 365 Finance and Operations is a complete enterprise resource planning (ERP) tool. Among its many capabilities are supply chain management, inventory control, and financial management. Within the field of inventory control, the correct and effective movement of products is mostly dependent on Transfer Journals and Transfer Orders.\nLet’s learn about them, one by one.\nWhat is a Transfer Journal?One simple tool for internal inventory movement in D365 Finance and Operations is a transfer journal. It lets organizations move goods between several sites inside the same warehouse or between closely spaced warehouses without including thorough tracking or shipping documents.\nTransfer journals are perfect for regular inventory changes and internal relocations because of their simplicity.\nScenarios for Transfer Journals:\nInternal Reorganization: Transfer Journals allow an organization to shift goods from one bin location to another inside the same warehouse when it needs to rearrange its warehouse layout. This simplifies the maintenance of an accurate record of inventory locations free from the complexity of shipping documentation.\nCorrecting Mistakes: A Transfer Journal allows one to rapidly rectify mistakes in items received with erroneous tracking numbers or at the wrong location. Businesses can keep exact traceability by moving goods between tracking dimensions, such as batch or serial numbers.\nClose Proximity Transfers: Transfer Journals help to streamline the process while goods are being moved between two geographically close warehouses. This simplifies the transfer procedure by removing the necessity for thorough tracking and documentation for delivery.\n\nHow to Create and Process a Transfer Journal?Creating and processing a Transfer Journal in D365 Finance and Operations involves a few straightforward steps:\n\nNavigate to Inventory Management &gt; Journal entries &gt; Items &gt; Transfer.\nCreate a new journal by clicking “New”. Add the required information including the journal name, description, site, and warehouse.\nEnter the item number, quantity, from site, to site, from warehouse, and to warehouse to add the items you wish to transfer.\nValidate the journal to look for mistakes. Post the journal once validated to complete the transfer. This will change the levels of inventory in the designated sites.\nNavigate to Inventory management &gt; Inquiries and reports &gt; Journals &gt; Item transactions to review the transfer specifics. To read the specifics, choose the journal you posted and click “Transactions”.\nGet Dynamics 365 Finance and Operations implemented by a top Microsoft Gold partner in the USA—Dynamics Square. Schedule a free consultation now!\n\n\n\nWhat is a Transfer Order?A transfer order in D365 Finance and Operations is designed as a completed tool for moving stocks between warehouses or sites where thorough tracking and shipping paperwork are needed.\nTransfer orders are appropriate for circumstances whereby objects must be tracked throughout travel since they offer more control and visibility over the transfer process.\nScenarios for Transfer Orders:\nLong-Distance Transfers: Transfer Orders guarantee that goods are being traced all through the transportation process when goods are being moved between warehouses that are far apart. Maintaining inventory accuracy depends on tracking, shipping, and receiving documents, hence this covers all aspects.\nShipping Documentation: Transfer orders are utilized when shipment documentation is needed to go along with the items. This is crucial for giving customers comprehensive shipment data and following shipping laws.\nWarehouse Management Processes: Transfer Orders fit very well in settings where warehouse staff members handle picking, packing, shipping, and receiving items. They guarantee that every stage of the transfer process is recorded and tracked.\n\nHow to Create and Process a Transfer Order?Creating and processing a Transfer Order in D365 Finance and Operations involves several detailed steps:\n\nVisit Inventory Management &gt; Outbound orders &gt; Transfer Order to navigate.\nClick “New” to draft a fresh transfer order. Now go into the “from” and “to” warehouses.\nEnter the item number and quantity to add the items you wish to move.\nGo to Inventory management &gt; Periodic &gt; Release transfer order picking. Click “OK,” then enter the transfer order number. Should the “Deduct released for picking” checkbox be chosen, the system will automatically deduct the pertinent quantity from the on-hand inventory.\nGo return to your transfer order and click “Ship” in the Action Pane. Check the quantity and product; then, click “OK” to post the shipment.\nGo to Inventory management &gt; Inbound orders &gt; Transfer order. Choose the transfer order then click “Receive” on the Action Pane. Check the quantity and product; then, to finish the receipt, click “OK.”\n\nKey Differences Between Transfer Journals and Transfer OrdersComplexity and Application\nTransfer Journals: Simple and flexible, transfer journals fit for internal relocation, error correction, and close proximity transfers.\nTransfer Orders: These are more complicated, suited for long-distance transfers, needing shipping documents, and interacting with warehouse management systems.\n\nTracking and Documentation\nTransfer Journals: Minimal tracking and no need for shipping documentation. Ideal for internal transfers where detailed tracking is unnecessary.\nTransfer Orders: Detailed tracking with shipping and receiving documentation. Ensures visibility and control over the transfer process.\n\nInventory ImpactTransfer Journals: Inventory movements are recorded without offsetting costs. Suitable for internal adjustments and corrections.Transfer Orders: Inventory and its value are tracked throughout the transfer process, with potential impacts on costing methods like moving or weighted average.\n","categories":["d365"]},{"title":"Flask Tutorial 1","url":"/2025/01/08/flask-tutorial/","content":"Flask TutorialProject Layout创建一个项目文件夹然后打开。\nmkdir flask-tutorial # 创建 flask 项目文件夹cd flask-tutorial\n\n按照 Flask Overview 设置项目目录。\n\n一个大的flask项目，不可以将所有的代码放到一个文件。Python项目使用package将代码组织成多个模块，这些模块可以在需要的地方导入。\n这个项目应该包含：\n\nflaskr/, 一个包含应用代码和文件的 python 包；\ntests/, 一个包含测试模块的目录；\n.venv/, 一个包含 flask 和其它已安装依赖的虚拟环境；\n一个告诉 python 如何安装项目的安装文件；\n版本控制配置，如 git。无论项目大小，你都应该养成对所有项目使用某种版本控制的习惯；\n如何可能在未来添加到项目的文件。\n\n最后，一个项目的结构应该如下：\n/home/user/Projects/flask-tutorial├── flaskr/│   ├── __init__.py│   ├── db.py│   ├── schema.sql│   ├── auth.py│   ├── blog.py│   ├── templates/│   │   ├── base.html│   │   ├── auth/│   │   │   ├── login.html│   │   │   └── register.html│   │   └── blog/│   │       ├── create.html│   │       ├── index.html│   │       └── update.html│   └── static/│       └── style.css├── tests/│   ├── conftest.py│   ├── data.sql│   ├── test_factory.py│   ├── test_db.py│   ├── test_auth.py│   └── test_blog.py├── .venv/├── pyproject.toml└── MANIFEST.in\n\n如果使用版本控制，可以如下设置。下列被指定的路径将会被版本控制忽略，即使它在项目的开发过程中被修改。\n.gitignore.venv/*.pyc__pycache__/instance/.pytest_cache/.coveragehtmlcov/dist/build/*.egg-info/\n\nApplication Setup一个 Flask 应用是一个 Flask 类的实例。任何与该应用相关的配置，URLs 都会在这个类中被注册。\n创建 Flask 引用的最直截了当的方式是在你代码的目录顶部创建一个全局的 Flask 实例。\n你将在一个函数中创建它，而不是全局地创建 Flask 的引用（实例）。这个函数称为 应用工厂。任何配置，注册和其它应用所需的设置都需要在这个函数中发生，然后返回该应用。\nThe Application Factory在 flaskr 目录下添加 __init__.py 文件，它有双重的职责，它将包含应用工厂，以及它告诉 python 这个 flaskr 目录应该被当作一个包。\nimport osfrom flask import Flaskdef create_app(test_config = None):    # Create and configue the app    app = Flask(__name__, instance_relative_config = True)    app.config.from_mapping(        SECRET_KEY = &#x27;dev&#x27;,        DATABASE = os.path.join(app.instance_path, &#x27;flaskr.sqlite&#x27;)    )    if test_config is None:        # Load the instance config, if it exists, when not testing        app.config.from_pyfile(&#x27;config.py&#x27;, silent = True)    else:        # Load the test config if passed in        app.config.from_mapping(test_config)    # ensure the instance folder exists    try:        os.makedirs(app.instance_path)    except OSError:        pass    # a simple page that says hello    @app.route(&#x27;/hello&#x27;)    def hello():        return &#x27;Hello, World!&#x27;        return app\n\ncreate_app 是一个应用工厂函数。你将在教程后面添加它，但它已经做了很多事儿。\n\napp = Flask(__name__, instance_relative_config = True) 创建了 Flask 实例。\n\n__name__ 是当前 python 模块的名字。这个 app 需要知道它的位置来设置一些路径。并且 __name__ 是一种很方便告诉它的方式；\ninstance_relative_config 告诉 app 配置文件是相对于实例文件夹的。实例文件夹位于flaskr包之外，可以保存不应该提交给版本控制的本地数据，例如配置秘密和数据库文件。\n\n\napp.config.from_mapping() 设置了 app 的一些默认配置：\n\nSECRET_KEY 被用来保证数据安全。它被设置为‘dev’，以便在开发期间提供一个方便的值，但在部署时应该使用随机值覆盖它；\nDATABASE 是 SQLite 数据库将被保存的位置。它在 app.instance_path 之下，这是Flask为实例文件夹选择的路径。\n\n\napp.config.from_pyfile() 使用从实例文件夹中的config.py文件（如果存在）获取的值覆盖默认配置。例如，在部署时，可以使用它来设置一个真正的SECRET_KEY。\n\nTest_config 也可以传递给工厂，并代替实例配置使用。\n\n\nos.makedir 确保 app.instance_path 存在，Flask 不会自动创建实例文件夹，但是它需要被创建因为当前的项目将创建数据库文件。\n\napp.route 创建了一个简单的路由，在深入后面教程之前我们可以看见应用是工作的。它创建了一个在 URL 和返回了响应的应用之间的连接。\n\n\nRun The Application现在可以使用flask命令运行应用程序了。在终端中，告诉Flask在哪里可以找到您的应用程序，然后在调试模式下运行它。记住，您仍然应该在顶层的flask-tutorial目录中，而不是在flask包中。\n调试模式在页面引发异常时显示交互式调试器，并在更改代码时重新启动服务器。您可以让它继续运行，只要按照本教程重新加载浏览器页面即可。\nflask --app flaskr run --debug* Serving Flask app &quot;flaskr&quot;* Debug mode: on* Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)* Restarting with stat* Debugger is active!* Debugger PIN: nnn-nnn-nnn\n\nDefine and Access the DatabaseSQLite 很方便因为它不需要设置一个独立的数据库服务，它是在 python 中编译的。但是，如果并发请求试图同时写入数据库，它们将会变慢，因为每次写入都是顺序进行的。小型应用程序不会注意到这一点。当您的企业规模扩大后，您可能希望切换到不同的数据库。\nConnect to the Database使用 SQLite 数据库（以及大多数其他Python数据库库）时要做的第一件事是创建到它的连接。任何查询和操作都使用连接执行，该连接在工作完成后关闭。\n在 web 应用程序中，这种连接通常与请求绑定在一起。它是在处理请求时创建的，并在发送响应之前关闭。\n\nflaskr&#x2F;db.py\n\nimport sqlite3from datetime import datetimeimport clickfrom flask import current_app, gdef get_db():    if &#x27;db&#x27; not in g:        g.db = sqlite3.connect(            current_app.config[&#x27;DATABASE&#x27;],            detect_types=sqlite3.PARSE_DECLTYPES        )        g.db.row_factory = sqlite3.Row    return g.dbdef close_db(e=None):    db = g.pop(&#x27;db&#x27;, None)    if db is not None:        db.close()\n\ng 是一个对于每个请求都唯一的对象。它用于存储在请求期间可能被多个函数访问的数据。如果在同一请求中第二次调用get_db，则存储并重用该连接，而不是创建新连接。\ncurrent_app 是另一个特殊对象，指向处理请求的Flask应用程序。由于使用了应用程序工厂，因此在编写其余代码时没有应用程序对象。Get_db将在创建应用程序并处理请求时调用，因此可以使用current_app。\nsqlite3.connect() 建立到DATABASE配置键所指向的文件的连接。这个文件并不一定要存在，直到稍后初始化数据库时才会存在。\nsqlite3.Row 告诉连接返回行为类似字典的行。这允许按名称访问列。\nclose_db 通过检查是否设置了g.db来检查是否创建了连接。如果连接存在，则关闭该连接。接下来，您将告诉应用程序有关应用程序工厂中的close_db函数，以便在每次请求之后调用它。\nCreate the TablesDROP TABLE IF EXISTS user;DROP TABLE IF EXISTS post;CREATE TABLE user (  id INTEGER PRIMARY KEY AUTOINCREMENT,  username TEXT UNIQUE NOT NULL,  password TEXT NOT NULL);CREATE TABLE post (  id INTEGER PRIMARY KEY AUTOINCREMENT,  author_id INTEGER NOT NULL,  created TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,  title TEXT NOT NULL,  body TEXT NOT NULL,  FOREIGN KEY (author_id) REFERENCES user (id));\n\n往 db.py 放入 python 方法用于运行 SQL 命令。\ndef init_db():    db = get_db()    with current_app.open_resource(&#x27;schema.sql&#x27;) as f:        db.executescript(f.read().decode(&#x27;utf8&#x27;))@click.command(&#x27;init-db&#x27;)def init_db_command():    init_db()    click.echo(&#x27;Initialized the database.&#x27;)sqlite3.register_converter(    &quot;timestamp&quot;, lambda v: datetime.fromisoformat(v.decode()))\n\nOpen_resource（）打开一个相对于flask包的文件，这很有用，因为在以后部署应用程序时，您不一定知道该位置在哪里。Get_db返回一个数据库连接，用于执行从文件中读取的命令。\ncommand（）定义了一个名为init-db的命令行命令，该命令调用init_db函数并向用户显示成功消息。您可以阅读命令行接口来了解更多关于编写命令的信息。\n调用sqlite3.register_converter（）告诉Python如何解释数据库中的时间戳值。我们将该值转换为datetime.datetime。\nRegister with the Applicationclose_db和init_db_command函数需要在应用实例中注册；否则，它们将不会被应用程序使用。但是，由于使用的是工厂函数，因此在编写函数时该实例不可用。相反，应该编写一个函数，它接受一个应用程序并进行注册。\ndef init_app(app):    app.teardown_appcontext(close_db)    app.cli.add_command(init_db_command)\n\napp.teardown_appcontext（）告诉Flask在返回响应后进行清理时调用该函数。\nApp.cli.add_command（）添加了一个可以通过flask命令调用的新命令。\n从工厂导入并调用这个函数。在返回应用程序之前，将新代码放在工厂函数的末尾。\n# a simple page that says hello@app.route(&#x27;/hello/&#x27;)def hello():    return &#x27;Hello, World!&#x27;\n\nInitialize the Database File现在init-db已经注册到应用程序中，可以使用flask命令调用它，类似于上一页中的run命令。\n\n如果您仍在运行上一页中的服务器，您可以停止服务器，或者在新的终端中运行此命令。如果您使用一个新的终端，请记住切换到您的项目目录并激活env，如安装中所述。\n\n运行init-db命令：\nflask --app flaskr init-db\n\n将会有一个 flaskr.sqlite 文件出现在项目的instance目录中\n","categories":["flask"]},{"title":"Site building tutorial","url":"/2025/07/08/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\nEnable comments for siteWe can use the utterances for implementing comments function. More info: utterances\nAdd the following script in the theme config.yml\nutteranc:  enable: true  repo: user_name/repo_name # Github repository owner and name  # Available values: pathname | url | title | og:title  issue_term: pathname  # Available values: github-light | github-dark | preferred-color-scheme | github-dark-orange | icy-dark | dark-blue | photon-dark | boxy-light  theme: github-dark\n\n​Additionally, we must edit the following property like the following:​\n# Multiple Comment System Supportcomments:  # Available values: tabs | buttons  style: tabs  # Choose a comment system to be displayed by default.  # Available values: disqus | disqusjs | changyan | livere | gitalk | utterances  active: utterances  # Setting `true` means remembering the comment system selected by the visitor.  storage: true  # Lazyload all comment systems.  lazyload: false  # Modify texts or order for any naves, here are some examples.  nav:"},{"title":"X++ api list","url":"/2024/12/23/xpp-api-list/","content":"FileIOPermissionFileIOPermission类用于设置文件的访问权限。assert()方法用于验证FileIOPermission类设置权限是否成功，如果错误，便会抛出错误，效果类似try catch程序块。\nRecordInsertList用于批量插入的工具类，示例代码如下：\n","categories":["x++"]},{"title":"The Way for Clearing the Log Disk","url":"/2024/12/23/mssql-clear-log/","content":"\n\nThe example SQL script code as shown below:\nuse [AxDB]SELECT name FROM sys.database_filesUSE [master]GOALTER DATABASE [AxDB] SET RECOVERY SIMPLE WITH NO_WAITGOUSE [AxDB]GODBCC SHRINKFILE (AxDB_Restore_log, 1024)GOUSE [master]GOALTER DATABASE [AxDB] SET RECOVERY FULL WITH NO_WAITGO","categories":["t-sql"]},{"title":"How to Copy the Add Items","url":"/2025/07/11/xpp-copyadditemsfeature/","content":"SummaryThe D365 F&amp;O has an out of box function named “Add products“, If developer develops an item-base table and wants to copy this function for this table. The following codes.\nCode ExampleTo begin with, we need to extend the standard system class to implement a custom strategy for loading default items in the ‘Add Productions’ dialog. When the user selects one or multiple lines and clicks the ‘Add Productions’ button, the dialog should automatically prefill the item field(s) based on the selected records.\nSecondly, we need to use a Chain of Command (CoC) extension on the createProducts method to implement the logic for adding items to the custom table.\n/// &lt;summary&gt;/// Willie Yao - 07/07/2025/// &lt;/summary&gt;[ExtensionOf(classStr(RetailCreateLinesFromProductsToAdd))]final class HMClass_RetailCreateLinesFromProductsToAdd_Extension&#123;    /// &lt;summary&gt;    /// Willie Yao - 07/07/2025    /// loadLinesFromCaller    /// &lt;/summary&gt;    /// &lt;param name=&quot;_callerArgs&quot;&gt;&lt;Args/param&gt;    /// &lt;param name=&quot;_tmpProductsToAdd&quot;&gt;TmpRetailProductsToAdd&lt;/param&gt;    public void loadLinesFromCaller(Args _callerArgs, TmpRetailProductsToAdd _tmpProductsToAdd)    &#123;        next loadLinesFromCaller(_callerArgs, _tmpProductsToAdd);        TableId callerTableId = _callerArgs.dataset();        switch (callerTableId)        &#123;            case tableNum(HMTable):                this.loadHMTable();                break;        &#125;    &#125;    /// &lt;summary&gt;    /// Willie Yao - 07/07/2025    /// loadHMTable    /// &lt;/summary&gt;    internal void loadHMTable()    &#123;        InventTable     inventTable;        EcoResProduct   ecoResProduct;        HMTable         MTable = callerArgs.record();        select firstonly product from inventTable            where inventTable.ItemId == MTable.ItemId            join ecoResProduct                where ecoResProduct.RecId == inventTable.Product;        this.loadLines(ecoResProduct, 1, InventDim::findOrCreateBlank().inventDimId);    &#125;    /// &lt;summary&gt;    /// Willie Yao - 07/07/2025    /// createProducts    /// &lt;/summary&gt;    /// &lt;param name=&quot;_tmpProductsToAdd&quot;&gt;TmpRetailProductsToAdd&lt;/param&gt;        public void createProducts(TmpRetailProductsToAdd _tmpProductsToAdd)    &#123;        next createProducts(_tmpProductsToAdd);        switch (common.TableId)        &#123;            case tableNum(HMTable):                this.createHMTable(HMTable::findByRecId(common.RecId), _tmpProductsToAdd);                break;        &#125;    &#125;    /// &lt;summary&gt;    /// Willie Yao - 07/07/2025    /// createHMTable    /// &lt;/summary&gt;    /// &lt;param name=&quot;_HMTable&quot;&gt;HMTable&lt;/param&gt;    /// &lt;param name=&quot;_tmpProductsToAdd&quot;&gt;TmpRetailProductsToAdd&lt;/param&gt;    internal void createHMTable(HMTable _HMTable, TmpRetailProductsToAdd _tmpProductsToAdd)    &#123;        HMTable HMTable;        ttsbegin;        while select _tmpProductsToAdd        &#123;            HMTable.clear();            HMTable.ItemId = _tmpProductsToAdd.ItemId;            // Others customized fields value populated logic.            if (HMTable.validateWrite())            &#123;                HMTable.insert();            &#125;                    &#125;        ttscommit;    &#125;&#125;\n\nFinally, we need to override the createCallerTableRecords method in the RetailAddItems form to trigger the logic for creating item records.\n/// &lt;summary&gt;/// Willie Yao - 07/07/2025/// &lt;/summary&gt;[ExtensionOf(formStr(RetailAddItems))]final class HMForm_RetailAddItems_Extension&#123;    /// &lt;summary&gt;    /// Willie Yao - 07/07/2025    /// createCallerTableRecords    /// &lt;/summary&gt;    /// &lt;param name=&quot;_callerTableId&quot;&gt;TableId&lt;/param&gt;    /// &lt;param name=&quot;_tmpInventTable&quot;&gt;TmpRetailProductsToAdd&lt;/param&gt;    public void createCallerTableRecords(TableId _callerTableId, TmpRetailProductsToAdd _tmpInventTable)    &#123;        next createCallerTableRecords(_callerTableId, _tmpInventTable);        switch (_callerTableId)        &#123;            case tableNum(HMTable):                this.createOrderLine(FormDataUtil::getFormDataSource(this.args().record()));                break;        &#125;    &#125;&#125;"},{"title":"Create ledger journals in D365FO using X++","url":"/2025/07/09/xpp-createledgerjournals/","content":"\nReprinted from: https://denistrunin.com/xpptools-createledgerjournal/\n\nCreating LedgerJournalTrans using X++ is quite a common task, but sometimes I still see some mistakes(mostly related to fields initialization from account&#x2F;offset account and voucher assignment). In this post, I’ll try to describe possible options how to create ledger journals in D365FO.\nTest scenarioTo test different methods, I wrote a Runnable class DEVTutorialCreateLedgerJournal that creates a new journal based on the data from the existing source journal using different methods. The dialog looks like this\n\n\nLet’s discuss possible copy options(Copy type parameter):\nLedgerJournalEngine classThis method is using LedgerJournalEngine class - the same class that is used when the user creates a journal manually on the Journal lines form. This increases the chances that the resulting line will be the same as a manually created line.\nwhile select ledgerJournalTransOrig    order by RecId            where ledgerJournalTransOrig.JournalNum == _ledgerJournalTableOrig.JournalNum&#123;    numLines++;    if (!ledgerJournalTable.RecId)    &#123;        //Often journal name from parameters is specified here        DEV::validateCursorField(ledgerJournalName, fieldNum(LedgerJournalName, JournalName));        ledgerJournalTable.clear();        ledgerJournalTable.initValue();        ledgerJournalTable.JournalName = ledgerJournalName.JournalName;        ledgerJournalTable.initFromLedgerJournalName();        ledgerJournalTable.JournalNum = JournalTableData::newTable(ledgerJournalTable).nextJournalId();        ledgerJournalTable.Name = strFmt(&quot;Copy of %1, Date %2&quot;, _ledgerJournalTableOrig.JournalNum, DEV::systemdateget());        ledgerJournalTable.insert();        info(strFmt(&quot;Journal %1 created&quot;, ledgerJournalTable.JournalNum));        ledgerJournalEngine = LedgerJournalEngine::construct(ledgerJournalTable.JournalType);        ledgerJournalEngine.newJournalActive(ledgerJournalTable);    &#125;    ledgerJournalTrans.clear();    ledgerJournalTrans.initValue();    ledgerJournalEngine.initValue(ledgerJournalTrans);    ledgerJournalTrans.JournalNum           =   ledgerJournalTable.JournalNum;    ledgerJournalTrans.TransDate            =   DEV::systemdateget();    ledgerJournalTrans.AccountType          =   ledgerJournalTransOrig.AccountType;    ledgerJournalTrans.modifiedField(fieldNum(LedgerJournalTrans, AccountType));    ledgerJournalTrans.LedgerDimension = ledgerJournalTransOrig.LedgerDimension;    if (!ledgerJournalTrans.LedgerDimension)    &#123;        throw error(&quot;Missing or invalid ledger dimension for journal process&quot;);    &#125;    ledgerJournalTrans.modifiedField(fieldNum(LedgerJournalTrans, LedgerDimension));    ledgerJournalEngine.accountModified(LedgerJournalTrans);    ledgerJournalTrans.OffsetAccountType = ledgerJournalTransOrig.OffsetAccountType;    ledgerJournalTrans.modifiedField(fieldNum(LedgerJournalTrans, OffsetAccountType));    ledgerJournalTrans.OffsetLedgerDimension = ledgerJournalTransOrig.OffsetLedgerDimension;    ledgerJournalTrans.modifiedField(fieldNum(LedgerJournalTrans, OffsetLedgerDimension));    ledgerJournalEngine.offsetAccountModified(ledgerJournalTrans);    //amounts    LedgerJournalTrans.CurrencyCode         =   ledgerJournalTransOrig.CurrencyCode;    ledgerJournalEngine.currencyModified(LedgerJournalTrans);    LedgerJournalTrans.AmountCurCredit      =   ledgerJournalTransOrig.AmountCurCredit;    LedgerJournalTrans.AmountCurDebit       =   ledgerJournalTransOrig.AmountCurDebit;    //additional fields    LedgerJournalTrans.Approver           = HcmWorker::userId2Worker(curuserid());    LedgerJournalTrans.Approved           = NoYes::Yes;    ledgerJournalTrans.Txt                = ledgerJournalTransOrig.Txt;    LedgerJournalTrans.SkipBlockedForManualEntryCheck = true;    DEV::validateWriteRecordCheck(ledgerJournalTrans);    ledgerJournalTrans.insert();    ledgerJournalEngine.write(ledgerJournalTrans);&#125;\n\nWhen you modify Account&#x2F;Offset account fields in this example you need to call two methods(on ledgerJournalTrans and ledgerJournalEngine). This ensures that the line will be properly initialized from the Account&#x2F;Offset account field.\nledgerJournalTrans.modifiedField(fieldNum(LedgerJournalTrans, LedgerDimension));  ledgerJournalEngine.accountModified(LedgerJournalTrans);\n\nVoucher assignment here is processing in ledgerJournalEngine.write().\nAlso, an interesting flag here is LedgerJournalTrans.SkipBlockedForManualEntryCheck. It is useful when you don’t want to allow users to create manually lines with the same accounts as in your procedure.\nLedgerJournalTrans defaultRow() methodThis is a new approach in D365FO and it uses a new defaultRow() table method. Data entities also call this method during the import process. Its idea is that we don’t control the sequence of different modifiedField method calls, we just populate the fields that we know, all other logic happens in the defaultRow() method.\nCode for journal creation in this case:\nwhile select ledgerJournalTransOrig    order by RecId    where ledgerJournalTransOrig.JournalNum == _ledgerJournalTableOrig.JournalNum&#123;    numLines++;    if (!ledgerJournalTable.RecId)    &#123;        ledgerJournalTable.clear();        ledgerJournalTable.initValue();        ledgerJournalTable.JournalName = _ledgerJournalTableOrig.JournalName;        ledgerJournalTable.initFromLedgerJournalName();        ledgerJournalTable.JournalNum = JournalTableData::newTable(ledgerJournalTable).nextJournalId();        ledgerJournalTable.Name = strFmt(&quot;Copy of %1, Date %2&quot;, _ledgerJournalTableOrig.JournalNum, DEV::systemdateget());        ledgerJournalTable.insert();        info(strFmt(&quot;Journal %1 created&quot;, ledgerJournalTable.JournalNum));    &#125;    ledgerJournalTrans.clear();    ledgerJournalTrans.initValue();    ledgerJournalTrans.JournalNum             = ledgerJournalTable.JournalNum;    ledgerJournalTrans.TransDate              = DEV::systemdateget();    ledgerJournalTrans.AccountType            = ledgerJournalTransOrig.AccountType;    ledgerJournalTrans.LedgerDimension        = ledgerJournalTransOrig.LedgerDimension;    ledgerJournalTrans.DefaultDimension       = ledgerJournalTransOrig.DefaultDimension;    ledgerJournalTrans.OffsetAccountType      = ledgerJournalTransOrig.OffsetAccountType;    ledgerJournalTrans.OffsetLedgerDimension  = ledgerJournalTransOrig.OffsetLedgerDimension;    ledgerJournalTrans.OffsetDefaultDimension = ledgerJournalTransOrig.OffsetDefaultDimension;    ledgerJournalTrans.CurrencyCode           =   ledgerJournalTransOrig.CurrencyCode;    ledgerJournalTrans.AmountCurCredit        =   ledgerJournalTransOrig.AmountCurCredit;    ledgerJournalTrans.AmountCurDebit         =   ledgerJournalTransOrig.AmountCurDebit;    //addition fields    ledgerJournalTrans.Approver           = HcmWorker::userId2Worker(curuserid());    ledgerJournalTrans.Approved           = NoYes::Yes;    ledgerJournalTrans.Txt                = ledgerJournalTransOrig.Txt;    ledgerJournalTrans.SkipBlockedForManualEntryCheck = true;    ledgerJournalTrans.defaultRow();    DEV::validateWriteRecordCheck(ledgerJournalTrans);    ledgerJournalTrans.insert();&#125;\n\nYou can find an example of this approach in the MCRLedgerJournal class (and the usage is here)\nData entityWe can also use a data entity for journal creation. Technically it produces the same result as the previous method because a data entity at the end will call a table defaultRow() method.\nwhile select ledgerJournalTransOrig    order by RecId    where ledgerJournalTransOrig.JournalNum == _ledgerJournalTableOrig.JournalNum&#123;    numLines++;    select dimensionCombinationEntity        where dimensionCombinationEntity.RecId == ledgerJournalTransOrig.LedgerDimension;    select dimensionCombinationEntityOffset        where dimensionCombinationEntityOffset.RecId == ledgerJournalTransOrig.OffsetLedgerDimension;    ledgerJournalEntity.initValue();    ledgerJournalEntity.JournalBatchNumber     = journalNum;    ledgerJournalEntity.Description            = strFmt(&quot;Copy of %1, Date %2&quot;, _ledgerJournalTableOrig.JournalNum, DEV::systemdateget());    ledgerJournalEntity.JournalName            = _ledgerJournalTableOrig.JournalName;    ledgerJournalEntity.LineNumber++;    //if you have string and want to convert to ID - DimensionDefaultResolver::newResolver(_dimensionDisplayValue).resolve();    //AX &gt; General ledge &gt; Chart of accounts &gt; Dimensions &gt; Financial dimension configuration for integrating applications    ledgerJournalEntity.AccountType                 = ledgerJournalTransOrig.AccountType;    ledgerJournalEntity.AccountDisplayValue         = dimensionCombinationEntity.DisplayValue;    ledgerJournalEntity.OffsetAccountType           = ledgerJournalTransOrig.OffsetAccountType;    ledgerJournalEntity.OffsetAccountDisplayValue   = dimensionCombinationEntityOffset.DisplayValue;    ledgerJournalEntity.CreditAmount                = ledgerJournalTransOrig.AmountCurCredit;    ledgerJournalEntity.DebitAmount                 = ledgerJournalTransOrig.AmountCurDebit;    ledgerJournalEntity.CurrencyCode                = ledgerJournalTransOrig.CurrencyCode;    ledgerJournalEntity.TEXT                        = ledgerJournalTransOrig.Txt;    ledgerJournalEntity.TRANSDATE                   = ledgerJournalTransOrig.TransDate;    ledgerJournalEntity.defaultRow();    DEV::validateWriteRecordCheck(ledgerJournalEntity);    ledgerJournalEntity.insert();    journalNum = ledgerJournalEntity.JournalBatchNumber;&#125;\n\nAs you see this method requires less code: we don’t even need to write code for the journal header creation, it is all handled by the data entity insert() method. Dimensions can be also specified as strings. However there are some limitations: sometimes data entity doesn’t contain all the table fields and it doesn’t support all account types.\nPerformance testingLet’s test the performance. First I created a test journal with the 1000 lines(createByCombination method) and then copied it using these 3 different methods. I got the following results:\n\n\n\nMethod\nTime to create 1000 lines(sec)\n\n\n\nUsing ledgerJournalEngine\n30.54\n\n\nUsing DataEntity\n33.09\n\n\nUsing Table defaultRow method\n15.18\n\n\nThere are some differences between the copy speed in my example, but it is caused by a different logic for the dimension creation, so the result is that all methods are almost equal and quite fast. In a real-life scenario, you can expect an insert speed 10-30 lines per second.\nChoosing the right method and things to avoidIn general, you have 2 options - to create a journal similar to the manual user entry or create it similar to the import procedure(for the second scenario choice between entity and table mostly depends on what input data you have and whether the entity supports all the required fields). So the choice between these two should be made by answering the question: if the user wants to create the same journal manually, does he use manual entry or data import? Use createJournalUsingLedgerJournalEngine as default, as it is more flexible.\nProbably in D365FO it is better to avoid creation using JournalTransData classes or when you simply populate ledgerJournalTrans fields and call insert(). This initially can work, but later users may complain - e.g. “Why when I create a journal manually and specify a vendor account the Due date field is calculated, but your procedure doesn’t fill it“.\nSummaryYou can download this class using the following link createJournalUsingLedgerJournalEngine. The idea is that you can use this code as a template when you have a task to create(or post) a ledger journal using X++. Comments are welcome.\n","categories":["x++"],"tags":["LedgerJournalTrans"]},{"title":"Dynamics 365 Debugging Configuration","url":"/2025/02/23/xpp-debug-configuration/","content":"\n当无法 debug 系统标准的代码时，可以按照本文的步骤配置\n\n导航 Tools &gt; Options，在 Dynamics 365 &gt; Debugging tab 页面配置 debug 相关属性，如下图，在 Included Packages 中选择，在 debug 中需要 load 的 model。\n","categories":["x++"]},{"title":"Extend CustTrans and VendTrans","url":"/2025/07/09/xpp-extendedvendtransandcusttrans/","content":"\nJust recorded how to extend the feature regards the CustTrans and VendTrans.\n\nBring the customized fields of LedgerJournalTrans to CustTrans or VendTransIf the requirement wants to create the new fields on CustTrans&#x2F;VendTrans and LedgerJournalTrans, and want to sync the customized fields to Transaction record after posting the customer journal or vendor journal. You can extend the CustVoucherJournal&#x2F;VendVoucherJournal as follows:\n/// &lt;summary&gt;/// Willie Yao - 07/08/2025/// &lt;/summary&gt;[ExtensionOf(classstr(CustVoucherJournal))]final class HMClass_CustVoucherJournal_Extension&#123;    /// &lt;summary&gt;    /// Willie Yao - 07/08/2025    /// &lt;/summary&gt;    /// &lt;param name = &quot;custVendTrans&quot;&gt;CustVendTrans&lt;/param&gt;    /// &lt;param name = &quot;_ledgerPostingJournal&quot;&gt;LedgerVoucher&lt;/param&gt;    /// &lt;param name = &quot;_useSubLedger&quot;&gt;UseSubLedger&lt;/param&gt;    protected void initCustVendTrans(        CustVendTrans   custVendTrans,         LedgerVoucher   _ledgerPostingJournal,         boolean         _useSubLedger)    &#123;        next initCustVendTrans(custVendTrans, _ledgerPostingJournal, _useSubLedger);                LedgerJournalTrans ledgerJournalTrans;        if (common.TableId == tablenum(LedgerJournalTrans))        &#123;            ledgerJournalTrans = common;            if (custVendTrans.TableId == tableNum(CustTrans))            &#123;                CustTrans custTrans  = custVendTrans;                custTrans.HMField1   = ledgerJournalTrans.HMField1;                custTrans.HMField2   = ledgerJournalTrans.HMField2;                custVendTrans        = custTrans;            &#125;        &#125;    &#125;&#125;/// &lt;summary&gt;/// Willie Yao - 07/08/2025/// &lt;/summary&gt;[ExtensionOf(classstr(VendVoucherJournal))]final class HMClass_VendVoucherJournal_Extension&#123;    /// &lt;summary&gt;    /// Willie Yao - 07/08/2025    /// &lt;/summary&gt;    /// &lt;param name = &quot;custVendTrans&quot;&gt;CustVendTrans&lt;/param&gt;    /// &lt;param name = &quot;_ledgerPostingJournal&quot;&gt;LedgerVoucher&lt;/param&gt;    /// &lt;param name = &quot;_useSubLedger&quot;&gt;UseSubLedger&lt;/param&gt;    protected void initCustVendTrans(        CustVendTrans   custVendTrans,         LedgerVoucher   _ledgerPostingJournal,         boolean         _useSubLedger)    &#123;        next initCustVendTrans(custVendTrans, _ledgerPostingJournal, _useSubLedger);        LedgerJournalTrans ledgerJournalTrans;        if (common.TableId == tablenum(LedgerJournalTrans))        &#123;            ledgerJournalTrans = common;            if (custVendTrans.TableId == tableNum(VendTrans))            &#123;                VendTrans vendTrans  = custVendTrans;                vendTrans.HMField1   = ledgerJournalTrans.HMField1;                custVendTrans        = vendTrans;            &#125;        &#125;    &#125;&#125;\n\nAdd new validation logic when posted LedgerJournalTransPlease coc the validation logic of LedgerJournalCheckPost class if developer wants to add new validation logic for LedgerJournalTrans post operation.\n/// &lt;summary&gt;/// Willie Yao - 07/08/2025/// &lt;/summary&gt;[ExtensionOf(classstr(LedgerJournalCheckPost))]final class HMClass_LedgerJournalCheckPost_Extension&#123;    /// &lt;summary&gt;    /// Willie Yao - 07/08/2025    /// &lt;/summary&gt;    /// &lt;param name = &quot;_calledFrom&quot;&gt;CalledFrom&lt;/param&gt;    /// &lt;returns&gt;True if validate right&lt;/returns&gt;    public boolean validate(Object _calledFrom)    &#123;        boolean ret = next validate(_calledFrom);        ret = this.newValidation() &amp;&amp; ret;        return ret;    &#125;    /// &lt;summary&gt;    /// Willie Yao - 07/08/2025    /// &lt;/summary&gt;    /// &lt;returns&gt;True if validate right&lt;/returns&gt;    internal boolean newValidation()    &#123;        LedgerJournalTrans  ledgerJournalTrans;        boolean             ok = true;        ok = this.newValidationLogic(ledgerJournalTrans) &amp;&amp; ok;        return ok;        &#125;&#125;\n\nExtend CustTrans&#x2F;VendTrans Reversal LogicDevelopers must coc the reversal method and write the customized logic after the next invoke method.\n/// &lt;summary&gt;/// Willie Yao - 07/08/2025/// &lt;/summary&gt;[ExtensionOf(classstr(TransactionReversal_Cust))]final class HMClass_TransactionReversal_Cust_Extension&#123;     /// &lt;summary&gt;    /// Willie Yao - 07/08/2025    /// &lt;/summary&gt;    /// &lt;param name = &quot;args&quot;&gt;Args&lt;/param&gt;    void reversal(Args args)    &#123;        next reversal(args);        // New Logic    &#125;    &#125;/// &lt;summary&gt;/// Willie Yao - 07/08/2025/// &lt;/summary&gt;[ExtensionOf(classstr(TransactionReversal_Vend))]final class HMClass_TransactionReversal_Vend_Extension&#123;    /// &lt;summary&gt;    /// Willie Yao - 07/08/2025    /// &lt;/summary&gt;    /// &lt;param name = &quot;args&quot;&gt;Args&lt;/param&gt;    void reversal(Args args)    &#123;        next reversal(args);        // New Logic    &#125;  &#125;\n\n\nMore expansion points will be updated successively in the future\n\n","categories":["x++"],"tags":["LedgerJournalTrans","CustTrans","VendTrans","Reversal"]},{"title":"How to create a new design for a Sales Invoice report in D365FO","url":"/2025/07/09/xpp-extendsalesinvoicereport/","content":"\nReprinted from: https://denistrunin.com/xpptools-createledgerjournal/\n\nCreating a new Sales Invoice report design using SSRS and X++ is quite a common task. In this post, I’ll try to describe how you can do this in Dynamics 365 Finance and Operations.\nSales Invoice report developmentI will use “DEVTutorial” prefix for new elements\nData provided classLet’s start with a data provider. We should create a new class and extend it from the standard SalesInvoiceDP. In this case, we can add additional fields that are relevant only for our report.\n[SRSReportParameterAttribute(classStr(SalesInvoiceContract))]class DEVTutorialSalesInvoiceDP  extends SalesInvoiceDP&#123;    protected void populateSalesInvoiceTmp(CustInvoiceJour _custInvoiceJour,            CustInvoiceTrans _custInvoiceTrans,            TaxSpec _taxSpec,            CustPaymSchedLine _custPaymSchedLine,            CustTrans _prepaymentCustTrans,            TaxTrans _prepaymentTaxTrans)    &#123;        super(_custInvoiceJour, _custInvoiceTrans, _taxSpec, _custPaymSchedLine, _prepaymentCustTrans, _prepaymentTaxTrans);        //populate additional fields in salesInvoiceTmp here        //salesInvoiceTmp.MyField = &#x27;&#x27;;        //this method is called for main lines and also for all linked tables        //please note, that it will not be called if there are already some data exist in salesInvoiceTmp table for the selected Sales order, you need to delete existing records       &#125;    protected void populateSalesInvoiceHeaderFooterTmp(CustInvoiceJour _custInvoiceJour, CompanyInfo _companyInfo)    &#123;        super(_custInvoiceJour, _companyInfo);        //populate additional fields in salesInvoiceTmp here        //salesInvoiceHeaderFooterTmp.MyField = &#x27;&#x27;;    &#125; &#125;\n\nReport designThen add a new SSRS report to our project\n\n\nWe need to add Datasets for this report. In the standard system we have 4 sales invoice datasets, let’s add them all.\n\n\n\nDataset name\nQuery\n\n\n\nSalesInvoiceDS\nSELECT * FROM DEVTutorialSalesInvoiceDP.SalesInvoiceTmp\n\n\nSalesInvoiceHeaderFooterDS\nSELECT * FROM DEVTutorialSalesInvoiceDP.SalesInvoiceHeaderFooterTmp\n\n\nSalesInvoiceLocalizationDS\nSELECT * FROM DEVTutorialSalesInvoiceDP.SalesInvoiceLocalizationTmp\n\n\nDocuBrandDetailsDS\nSELECT * FROM DEVTutorialSalesInvoiceDP.SysDocuBrandDetailsRegular\n\n\nAt the end you should have something like that:\n\n\nReport DesignThen let’s add a new Precision Design(Report)\nModify its properties: Size to standard A4 210x297mm and all Margins to 0.\n\n\nAdd the following sections\nHeader sectionFor the header, let’s add a logo from Document branding\n=First(Fields!Image1.Value, &quot;DocuBrandDetailsDS&quot;)\n\nand some client information\n=First(Fields!SalesId.Value, &quot;SalesInvoiceHeaderFooterDS&quot;)   &amp; vbcrlf &amp;  First(Fields!InvoiceDate.Value, &quot;SalesInvoiceHeaderFooterDS&quot;)  &amp; vbcrlf &amp;First(Fields!InvoicingAddress.Value, &quot;SalesInvoiceHeaderFooterDS&quot;)\n\nLine sectionAdd a new Tablix control with SalesInvoiceDS dataset\n\n\nAdjust Row visibility to the following formula “&#x3D;IIF(Fields!ItemId.Value &#x3D; “”, true, false)” as SalesInvoiceDS may contain data from linked tables(like payment schedule)\n\n\nLet’s also add a totals section. The resulting design should look like this.\n\n\nConnect a new report to Print managementA sales invoice can be used in a Print management module. In order to connect our report to this module, we need to subscribe to two events(create 2 new classes):\nUpdate 25&#x2F;11&#x2F;2021. A more detailed description can be found in the following blog How to Add New Report Format to Print Management\n[ExtensionOf(classstr(PrintMgmtReportFormatPopulator))]final class PrintMgmtReportFormatPopulatorDEVTutorial_Extension&#123;   protected void addDocuments()    &#123;        this.addStandard(PrintMgmtDocumentType::SalesOrderInvoice);        next addDocuments();    &#125; &#125;final static class PrintMgmtDocTypeDEVTutorial_EventHandler&#123;     [SubscribesTo(classstr(PrintMgmtDocType), delegatestr(PrintMgmtDocType, getDefaultReportFormatDelegate))]    public static void getDefaultReportFormatDelegate(PrintMgmtDocumentType _docType, EventHandlerResult _result)    &#123;   switch (_docType)        &#123;            case PrintMgmtDocumentType::SalesOrderInvoice:                _result.result(ssrsReportStr(DEVTutorialSalesInvoice, Report));                break;        &#125;  &#125; &#125;\n\nTest Sales invoice reportThat is all. It is time to test our report.\nBuild and deploy the report. Then, before the test, you need to add it to the print management settings. In order to do this - run the following job\nclass DEVTutorialPopulateReports&#123;   public static void main(Args _args)    &#123;        PrintMgmtReportFormatPopulator::construct().populate();    &#125;&#125;\n\nNext step is to add a logo to our report. Go to the Document images form and upload the image. Then go to the Branding details form and select this image.\nTo print the invoice go to the Accounts receivable - Invoice journal, select Document - Original preview and you should see our sample report:\n\n\nThe future of SSRS reportingThere may be a question of what is the future of SSRS reporting. Considering the latest news, I think that its popularity may grow. Microsoft recently released Power BI Paginated Reports that are completely based on SSRS “rdl” files. Technically a new Power BI Paginated Reports Builder is an old SSRS report builder with a new name(yes, another name change).\nCheck, for example, this recent course Power BI Paginated Reports in a Day course. Almost all its modules(except maybe 04) are relevant to D365FO development.\nAnd this Bear in the previous picture is not just a funny picture, it is an official mascot of Power BI Paginated Reports. So with a new name and a new Bear, I hope the popularity of SSRS may grow.\nSSRS reporting issuesIf you watch this “Power BI Paginated reports Day course“ you may feel that SSRS is cool(presentation is really great). However, the last main update for Report Builder was 10 years ago and the current version has some issues. Just some of them:\n\n“rdl” file is a very complex XML format. So in most cases, you will not be able to compare changes in the report - by using text compare you will see a huge number of differences in XML structure even for a small design change.\nPage splitting is very basic. For example, if you have a data row that consists of multiple lines and you want to avoid page breaks inside this row, you may find that this is not supported and you need to develop your own page grouping solution.\nYou can’t define a section that prints something on the footer of the last report page(and it is a quite popular requirement for reports - often it contains some bank payment information). There is a workaround for this if your report has 1 or 2 pages - you can put this information on page footer and hide the element using Globals!PageNumber and Globals!TotalPages variables, but if a report has 3 or more pages this will leave an empty space on these pages.\nReport designer doesn’t support formulas for defining Width property.So there are a lot of things that can be improved, and I hope Microsoft will invest in it.\n\nSummaryReal-life invoice reports can be quite complex and require a lot of efforts to create them. However, as we see, creating a simple Sales Invoice design is not a complex task. You can use the project above as a starting point(another option to consider is to install modern design templates).\nIf you have some hints for SSRS report development, don’t hesitate to post a comment. The project used in this post can be downloaded from my GitHub(you can download a model to a temporary folder and add elements from it to your project using “Add - Existing item..” command)\n","categories":["x++"],"tags":["ssrs","sales invoice report"]},{"title":"How to bring the sub billing schedule customized field value to sales order","url":"/2025/07/11/xpp-extendsubbillingschedule/","content":"Developer can extend SubBillCreateSalesOrder class to extend the customized fields value populated logic. Please see the example code:\n/// &lt;summary&gt;/// Willie Yao - 07/04/2025/// The extension class for SubBillCreateSalesOrder/// &lt;/summary&gt;[ExtensionOf(classStr(SubBillCreateSalesOrder))]final class HMClass_SubBillCreateSalesOrder_Extension&#123;    /// &lt;summary&gt;    /// Willie Yao - 07/04/2025    /// Coc the &lt;c&gt;createSalesLine&lt;/c&gt; method for initialing the sales line&#x27;s customized fields.    /// &lt;/summary&gt;    /// &lt;param name=&quot;_salesLine&quot;&gt;SalesLine&lt;/param&gt;    /// &lt;param name=&quot;_salesLineConsolidated&quot;&gt;SubBillSalesLineConsolidated&lt;/param&gt;    /// &lt;param name=&quot;_salesIdCon&quot;&gt;_salesIdCon&lt;SalesId/param&gt;    /// &lt;param name=&quot;_allocEnabled&quot;&gt;AllocEnabled&lt;/param&gt;    /// &lt;param name=&quot;_splitByItemGroup&quot;&gt;SplitByItemGroup&lt;/param&gt;    /// &lt;param name=&quot;_isInvoiceCreator&quot;&gt;IsInvoiceCreator&lt;/param&gt;    /// &lt;param name=&quot;_includeBillingDatesToItem&quot;&gt;IncludeBillingDatesToItem&lt;/param&gt;    /// &lt;returns&gt;SalesLine&lt;/returns&gt;    public static SalesLine createSalesLine(        SalesLine _salesLine,        SubBillSalesLineConsolidated _salesLineConsolidated,        SalesId _salesIdCon,        boolean _allocEnabled,        boolean _splitByItemGroup,        boolean _isInvoiceCreator,        boolean _includeBillingDatesToItem)    &#123;        SubBillScheduleLine     scheduleLine    = SubBillScheduleLine::find(_salesLineConsolidated.SubBillBillingScheduleNumber, _salesLineConsolidated.LineNum);        SubBillScheduleTable    scheduleTable   = SubBillScheduleTable::find(_salesLineConsolidated.SubBillBillingScheduleNumber);        SalesLine               salesLine       = next createSalesLine(_salesLine, _salesLineConsolidated, _salesIdCon, _allocEnabled, _splitByItemGroup, _isInvoiceCreator, _includeBillingDatesToItem);                if (scheduleLine)        &#123;            salesLine.HMField1 = scheduleLine.HMField1;            salesLine.HMField2 = scheduleLine.HMField2;        &#125;        return salesLine;    &#125;    /// &lt;summary&gt;    /// Willie Yao - 07/04/2025    /// Coc the initSalesTable method    /// &lt;/summary&gt;    /// &lt;param name=&quot;_salesTable&quot;&gt;SalesTable&lt;/param&gt;    /// &lt;param name=&quot;_isInvoiceCreator&quot;&gt;IsInvoiceCreator&lt;/param&gt;    /// &lt;param name=&quot;_numberSeq&quot;&gt;NumberSeq&lt;/param&gt;    /// &lt;param name=&quot;_salesLineConsolidated&quot;&gt;SalesLineConsolidated&lt;/param&gt;    /// &lt;param name=&quot;_curParmId&quot;&gt;CurParmId&lt;/param&gt;    /// &lt;returns&gt;SalesTable&lt;/returns&gt;    public static SalesTable initSalesTable(        SalesTable _salesTable,        boolean _isInvoiceCreator,        NumberSeq _numberSeq,        SubBillSalesLineConsolidated _salesLineConsolidated,        ParmId _curParmId)    &#123;        SubBillScheduleTable    scheduleTable   = SubBillScheduleTable::find(_salesLineConsolidated.SubBillBillingScheduleNumber);        SalesTable              salesTable      = next initSalesTable(_salesTable, _isInvoiceCreator, _numberSeq, _salesLineConsolidated, _curParmId);        if (scheduleTable)        &#123;            salesTable.HMField1 = scheduleTable.HMField1;            salesTable.HMField2 = scheduleTable.HMField2;        &#125;        return salesTable;        &#125;    /// &lt;summary&gt;    /// Willie Yao - 07/04/2025    /// Coc the createSalesOrder method    /// &lt;/summary&gt;    /// &lt;param name=&quot;_createSalesHeader&quot;&gt;CreateSalesHeader&lt;/param&gt;    /// &lt;param name=&quot;_salesId&quot;&gt;SalesId&lt;/param&gt;    /// &lt;param name=&quot;salesLineConsolidated&quot;&gt;SubBillSalesLineConsolidated&lt;/param&gt;    /// &lt;param name=&quot;_consolidateByCustomer&quot;&gt;ConsolidateByCustomer&lt;/param&gt;    /// &lt;param name=&quot;_splitByItemGroup&quot;&gt;SplitByItemGroup&lt;/param&gt;    /// &lt;param name=&quot;_returnValues&quot;&gt;ReturnValues&lt;/param&gt;    /// &lt;param name=&quot;_includeBillingDatesToItem&quot;&gt;IncludeBillingDatesToItem&lt;/param&gt;    /// &lt;param name=&quot;_isInvoiceCreator&quot;&gt;IsInvoiceCreator&lt;/param&gt;    /// &lt;param name=&quot;_creditAdjMethod&quot;&gt;CreditAdjMethod&lt;/param&gt;    /// &lt;param name=&quot;_terminationDate&quot;&gt;TerminationDate&lt;/param&gt;    /// &lt;param name=&quot;_prorateDaily&quot;&gt;ProrateDaily&lt;/param&gt;    /// &lt;param name=&quot;_curParmId&quot;&gt;CurParmId&lt;/param&gt;    /// &lt;param name=&quot;_consolidateAllPeriods&quot;&gt;ConsolidateAllPeriods&lt;/param&gt;    /// &lt;returns&gt;container&lt;/returns&gt;    public static container createSalesOrder(        boolean _createSalesHeader,        SalesId _salesId,        SubBillSalesLineConsolidated salesLineConsolidated,        boolean _consolidateByCustomer,        boolean _splitByItemGroup,        container _returnValues,        boolean _includeBillingDatesToItem,        boolean _isInvoiceCreator,        SubBillCreditDeferralAdjMethod _creditAdjMethod,        SubBillTerminationDate _terminationDate,        boolean _prorateDaily,        ParmId _curParmId,        boolean _consolidateAllPeriods)    &#123;        SubBillScheduleTable scheduleTable = SubBillScheduleTable::find(salesLineConsolidated.SubBillBillingScheduleNumber);        if(!_createSalesHeader)        &#123;                        SalesTable salesTableForUpt;            ttsbegin;            update_recordset salesTableForUpt                setting HMField1 = scheduleTable.HMField1,                        HMField2 = scheduleTable.HMField2                where salesTableForUpt.SalesId == _salesId;            ttscommit;        &#125;        container newReturnContainer = next createSalesOrder(_createSalesHeader, _salesId, salesLineConsolidated, _consolidateByCustomer, _splitByItemGroup, _returnValues, _includeBillingDatesToItem, _isInvoiceCreator,_creditAdjMethod, _terminationDate, _prorateDaily, _curParmId, _consolidateAllPeriods);                return newReturnContainer;    &#125;&#125;","categories":["x++"],"tags":["SalesTable","SubBillingSchedule","SubBillingScheduleLine","SalesLine","Extend"]},{"title":"Get selected records in a grid on a form - X++","url":"/2025/07/08/xpp-getselectedrecords/","content":"If you can get the form data source element, then you can get the selected records. Developers usually can get the args in the source code. That is a sally port for extracting the selected records.\n\npublic static void main(Args _args)\n&#123;\n    FormRun formRun = _args.caller();\n    FormDataSource formDS = formRun.dataSource();\n    SalesTable salesTable; // Use the SalesTable for testing.\n\n    while (salesTable = formDS.mark(1) ? formDS.cursor() : formDS.getFirst(1);\n            salesTable:\n            salesTable.getNext())\n    &#123;&#125;\n&#125;\n\npublic void modified()\n&#123;\n    SalesTable salesTable; // Use the SalesTable for testing.\n\n    while (salesTable = SalesTable_ds.mark(1) ? SalesTable_ds.cursor() : SalesTable_ds.getFirst(1);\n            salesTable:\n            salesTable.getNext())\n    &#123;&#125;\n&#125;\n\n···\n\n","categories":["x++"]},{"title":"Invoice Purchase Order Example","url":"/2025/02/23/xpp-invoice-purchase-order/","content":"\n本文记录了 x++ 代码 invoice 采购订单的示例代码\n\nHere is the C# code you provided with all comments removed:```csharppublic class GNCAutoInvoiceVendConsignedPOBatch extends RunBaseBatch implements BatchRetryable&#123;    SysLookupMultiSelectValues  gInvoiceIds;    boolean                     gCreateParmTable;    PurchTable                  gPurchTable;    boolean                     gMultiPOs;    PurchId                     gPurchId;    RecordInsertList            gParmLineRecordInsertList, gParmSubLineRecordInsertList, gMarkupTrans;    systemSequence              gSystemSequence;    Num                         gInvoiceNumber;    TransDate                   gInvoiceDate        = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());    InvoiceDescriptionLarge     gDescription;    Map                         gTableRefIdMap      = new Map(Types::String, Types::String);    Map                         gItemMap            = new Map(Types::String, Types::Real);    DialogField     gDlgInvoiceIds;    #define.CurrentVersion(1)    #localmacro.CurrentList        gInvoiceIds    #endmacro    public boolean canGoBatch()    &#123;        return true;    &#125;    public boolean canGoBatchJournal()    &#123;        return true;    &#125;    public Object dialog()    &#123;        DialogRunbase       dialog = super();            gDlgInvoiceIds = dialog.addFieldValue(extendedTypeStr(SysLookupMultiSelectValues), gInvoiceIds, &quot;@SYS12128&quot;);            return dialog;    &#125;    public void dialogPostRun(DialogRunbase _dialog)    &#123;        super(_dialog);        Query                   query;        QueryBuildDataSource    qbds;        query   = new Query(queryStr(GNCAutoInvoiceVendConsignedLookupQuery));        SysLookupMultiSelectCtrl::constructWithQuery(                    _dialog.dialogForm().formRun(),                    gDlgInvoiceIds.control(),                    query,                    false,                    [tableNum(CustInvoiceJour), fieldNum(CustInvoiceJour, InvoiceId)]        );    &#125;    public boolean getFromDialog()    &#123;        gInvoiceIds = gDlgInvoiceIds.value();            return super();    &#125;    public container pack()    &#123;        return [#CurrentVersion, #CurrentList];    &#125;    static GNCAutoInvoiceVendConsignedPOBatch construct()    &#123;        return new GNCAutoInvoiceVendConsignedPOBatch();    &#125;    static ClassDescription description()    &#123;        return &quot;@GNC:AutoInvoiceVendorConsignedPurchaseOrder&quot;;    &#125;    static void main(Args _args)    &#123;        GNCAutoInvoiceVendConsignedPOBatch      batch;            batch = GNCAutoInvoiceVendConsignedPOBatch::construct();            if (batch.prompt())        &#123;            batch.runOperation();        &#125;    &#125;    protected boolean canRunInNewSession()    &#123;        return false;    &#125;    [Hookable(false)]    public final boolean isRetryable()    &#123;        return false;    &#125;    public Qty getFinalInvoiceQty(ItemId _itemId, Qty _qty)    &#123;        Qty retQty, storeQty;        GNCProcessedVendorConsignedInvAdjustments processedVendorConsignedInvAdjustments = GNCProcessedVendorConsignedInvAdjustments::find(_itemId, true);        if (processedVendorConsignedInvAdjustments.RecId)        &#123;            ttsbegin;            storeQty = processedVendorConsignedInvAdjustments.Qty;            retQty = _qty - storeQty;            processedVendorConsignedInvAdjustments.Qty = retQty &lt; 0 ? abs(retQty) : 0;            processedVendorConsignedInvAdjustments.update();            ttscommit;        &#125;        else        &#123;            retQty = _qty;        &#125;        return retQty;    &#125;    public void run()    &#123;        #OCCRetryCount        setPrefix(&quot;@GNC:AutoInvoiceVendorConsignedPurchaseOrder&quot;);                query                       query_Item      = new Query(queryStr(GNCAutoInvoiceVendConsignedItemQuery));        QueryBuildDataSource        qbds;        SysLookupMultiSelectValues  qrvInvoiceIds   = strReplace(gInvoiceIds, &#x27;;&#x27;, &#x27;,&#x27;);                if (qrvInvoiceIds)        &#123;            qbds = query_Item.dataSourceTable(tableNum(CustInvoiceJour));            qbds.addRange(fieldNum(CustInvoiceJour, InvoiceId)).value(qrvInvoiceIds);        &#125;        QueryRun                    queryRunItem    = new QueryRun(query_Item);        TransDateTime               earliestDateTime;        while (queryRunItem.next())        &#123;            CustInvoiceTrans custInvoiceTrans_Item = queryRunItem.get(tableNum(CustInvoiceTrans));            Qty finalInvoiceQty = this.getfinalInvoiceQty(custInvoiceTrans_Item.ItemId, custInvoiceTrans_Item.Qty);            PurchLine   purchLine_earliest;            PurchTable  purchTable_earliest;                        select firstonly minof(CreatedDateTime) from purchTable_earliest                where purchTable_earliest.PurchaseType              == PurchaseType::Purch                exists join purchLine_earliest                    where purchLine_earliest.PurchId                == purchTable_earliest.PurchId                        &amp;&amp; !purchLine_earliest.Blocked                        &amp;&amp; !purchLine_earliest.IsDeleted                        &amp;&amp; (purchLine_earliest.PurchStatus          == PurchStatus::Backorder                        || purchLine_earliest.PurchStatus           == PurchStatus::Received)                        &amp;&amp; purchLine_earliest.ItemId                == custInvoiceTrans_Item.ItemId                        &amp;&amp; purchLine_earliest.RemainPurchFinancial  &gt; 0;            if (!earliestDateTime || earliestDateTime &gt; purchTable_earliest.CreatedDateTime)            &#123;                earliestDateTime = purchTable_earliest.CreatedDateTime;            &#125;        &#125;        if (!gItemMap.empty())        &#123;            while select gPurchTable                where gPurchTable.PurchaseType      == PurchaseType::Purch                    &amp;&amp; gPurchTable.CreatedDateTime  &gt;= earliestDateTime                    &amp;&amp; (gPurchTable.PurchStatus     == PurchStatus::Backorder                    || gPurchTable.PurchStatus      == PurchStatus::Received)            &#123;                try                &#123;                    this.processSinglePO();                &#125;                catch (Exception::Deadlock)                &#123;                    retry;                &#125;                catch (Exception::UpdateConflict)                &#123;                    if (appl.ttsLevel() == 0)                    &#123;                        if (xSession::currentRetryCount() &gt;= #RetryNum)                        &#123;                            throw Exception::UpdateConflictNotRecovered;                        &#125;                        else                        &#123;                            retry;                        &#125;                    &#125;                    else                    &#123;                        throw Exception::UpdateConflict;                    &#125;                &#125;                catch                &#123;                    if (appl.ttsLevel() != 0)                    &#123;                        ttsabort;                    &#125;                    continue;                &#125;            &#125;            this.insertExceptions();        &#125;        Query   query_jour = new Query();        qbds = query_jour.addDataSource(tableNum(CustInvoiceJour));                if (qrvInvoiceIds)        &#123;            qbds = query_jour.dataSourceTable(tableNum(CustInvoiceJour));            qbds.addRange(fieldNum(CustInvoiceJour, InvoiceId)).value(qrvInvoiceIds);        &#125;        QueryRun    queryRunJour    = new QueryRun(query_jour);                while (queryRunJour.next())        &#123;            try            &#123;                CustInvoiceJour custInvoiceJourUpd = queryRunJour.get(tableNum(CustInvoiceJour));                custInvoiceJourUpd.selectForUpdate(true);                ttsbegin;                custInvoiceJourUpd.GNCProcessedVendConsignedInvoice = true;                custInvoiceJourUpd.update();                ttscommit;            &#125;            catch (Exception::Deadlock)            &#123;                retry;            &#125;            catch (Exception::UpdateConflict)            &#123;                if (appl.ttsLevel() == 0)                &#123;                    if (xSession::currentRetryCount() &gt;= #RetryNum)                    &#123;                        throw Exception::UpdateConflictNotRecovered;                    &#125;                    else                    &#123;                        retry;                    &#125;                &#125;                else                &#123;                    throw Exception::UpdateConflict;                &#125;            &#125;            catch            &#123;                if (appl.ttsLevel() != 0)                &#123;                    ttsabort;                &#125;                continue;            &#125;        &#125;    &#125;    public void processSinglePO()    &#123;        PurchLine                   purchLine, prevPurchLine;        VendPackingSlipTrans        vendPackingSlipTrans;        Map                         packingSlipTransMap = new Map(Types::Int64, Types::Real);        QueryRun                    queryRun;        CustInvoiceTrans            custInvoiceTrans;        Qty                         qtyToInvoice;                    gPurchId = gPurchTable.PurchId;        this.initParameters();        this.initRecordLists();        while select purchLine            where purchLine.PurchId                             == gPurchTable.PurchId                &amp;&amp; !purchLine.Blocked                &amp;&amp; !purchLine.IsDeleted                &amp;&amp; (purchLine.PurchStatus                       == PurchStatus::Backorder                || purchLine.PurchStatus                        == PurchStatus::Received)                &amp;&amp; purchLine.RemainPurchFinancial               &gt; 0                join vendPackingSlipTrans                    where vendPackingSlipTrans.InventTransId    == purchLine.InventTransId        &#123;            Qty         purchRemain = vendPackingSlipTrans.remainPurchFinancial();            Qty         curQty;                        if (!purchRemain)            &#123;                continue;            &#125;            if (!gItemMap.exists(purchLine.ItemId))            &#123;                continue;            &#125;            qtyToInvoice = gItemMap.lookup(purchLine.ItemId);            if (!qtyToInvoice)            &#123;                continue;            &#125;            if (qtyToInvoice &gt; purchRemain)            &#123;                curQty          = purchRemain;                qtyToInvoice    -= purchRemain;            &#125;            else            &#123;                curQty          = abs(qtyToInvoice);                qtyToInvoice    = 0;            &#125;            if (purchLine.RecId != prevPurchLine.RecId)            &#123;                if (packingSlipTransMap.elements() &gt; 0)                &#123;                    this.createParmLineAndSubLines(prevPurchLine, packingSlipTransMap.pack());                &#125;                prevPurchLine       = purchLine.data();                packingSlipTransMap = new Map(Types::Int64, Types::Real);            &#125;            packingSlipTransMap.insert(vendPackingSlipTrans.RecId, curQty);            gItemMap.insert(purchLine.ItemId, qtyToInvoice);        &#125;        if (prevPurchLine.RecId &amp;&amp; packingSlipTransMap.elements() &gt; 0)        &#123;            this.createParmLineAndSubLines(prevPurchLine, packingSlipTransMap.pack());        &#125;        if (gCreateParmTable)        &#123;            gInvoiceNumber = gPurchTable.PurchId;            VendInvoiceJour vendInvoiceJour;            Counter         i;            select firstonly RecId from vendInvoiceJour                where vendInvoiceJour.InvoiceId == gInvoiceNumber;            while (vendInvoiceJour.RecId)            &#123;                i++;                vendInvoiceJour.clear();                gInvoiceNumber = strfmt(&#x27;%1_%2&#x27;, gPurchTable.PurchId, i);                select firstonly RecId from vendInvoiceJour                    where vendInvoiceJour.InvoiceId == gInvoiceNumber;            &#125;            VendInvoiceInfoTable        vendInvoiceInfoTable;            ttsbegin;            vendInvoiceInfoTable = this.createParmTable();            this.insertRecordLists();                        PurchFormLetter_Invoice purchFormLetter = PurchFormLetter_Invoice::newFromSavedInvoice(vendInvoiceInfoTable);            purchFormLetter.purchTable(gPurchTable);            purchFormLetter.printFormLetter(false);            purchFormLetter.proforma(false);            purchFormLetter.parmId(vendInvoiceInfoTable.ParmId);            purchFormLetter.update(vendInvoiceInfoTable, vendInvoiceInfoTable.Num);            ttscommit;            select firstonly RecId from vendInvoiceJour                where vendInvoiceJour.InvoiceId == vendInvoiceInfoTable.Num;            if (vendInvoiceJour)            &#123;                Info(strFmt(&quot;Vendor invoice journal %1 is posted.&quot;, vendInvoiceInfoTable.Num));            &#125;        &#125;    &#125;    public void insertExceptions()    &#123;        MapEnumerator itemME = gItemMap.getEnumerator();        while (itemME.moveNext())        &#123;            ItemId                      itemId  = itemME.currentKey();            Qty                         qtyExce = itemME.currentValue();             if (!qtyExce)            &#123;                continue;            &#125;            query                       query   = new Query(queryStr(GNCAutoInvoiceVendConsignedQuery));            QueryBuildDataSource        qbds;            SysLookupMultiSelectValues  qrvInvoiceIds   = strReplace(gInvoiceIds, &#x27;;&#x27;, &#x27;,&#x27;);            QueryRun                    queryRun;                        qbds = query.dataSourceTable(tableNum(CustInvoiceTrans));            qbds.addRange(fieldNum(CustInvoiceTrans, ItemId)).value(itemId);            if (qrvInvoiceIds)            &#123;                qbds = query.dataSourceTable(tableNum(CustInvoiceJour));                qbds.addRange(fieldNum(CustInvoiceJour, InvoiceId)).value(qrvInvoiceIds);            &#125;            queryRun = new QueryRun(query);            while (queryRun.next())            &#123;                CustInvoiceTrans    custInvoiceTrans = queryRun.get(tableNum(CustInvoiceTrans));                Qty                 qtyRemain, curQty;                qtyRemain = custInvoiceTrans.Qty;                if (qtyExce &gt; qtyRemain)                &#123;                    curQty      = qtyRemain;                    qtyExce     -= qtyRemain;                &#125;                else                &#123;                    curQty      = qtyExce;                    qtyExce     = 0;                &#125;                GNCAutoInvoiceVendConsignedException::create(gInvoiceDate,                     custInvoiceTrans.SalesId,                     custInvoiceTrans.InvoiceDate,                     custInvoiceTrans.ItemId,                     custInvoiceTrans.Qty,                     curQty);                if (!qtyExce)                &#123;                    break;                &#125;            &#125;        &#125;    &#125;    public void initParameters()    &#123;        gSystemSequence     = new systemSequence();        gCreateParmTable    = false;    &#125;    public TradeLineRefId getTableRefId()    &#123;        if (!gTableRefIdMap.exists(gPurchId))        &#123;            gTableRefIdMap.insert(gPurchId, formletterParmData::getNewTableRefId());        &#125;        return gTableRefIdMap.lookup(gPurchId);    &#125;    public void initRecordLists()    &#123;        gParmLineRecordInsertList       = new RecordInsertList(tableNum(VendInvoiceInfoLine));        gParmSubLineRecordInsertList    = new RecordInsertList(tableNum(VendInvoiceInfoSubLine));        gMarkupTrans    = new RecordInsertList(tableNum(MarkupTrans));    &#125;    public void insertParmLine(VendInvoiceInfoLine _vendInvoiceInfoLine, PurchLine _purchLine)    &#123;        gSystemSequence.suspendRecIds(_vendInvoiceInfoLine.TableId);        _vendInvoiceInfoLine.RecId  = gSystemSequence.reserveValues(1, _vendInvoiceInfoLine.TableId);        gParmLineRecordInsertList.add(_vendInvoiceInfoLine);    &#125;    public void createVendInvoiceMatchingLine(PurchLine _purchLine, VendDocumentLineMap _parmLine)    &#123;        VendInvoiceMatchingLine vendInvoiceMatchingLine;        if (_parmLine.TableId &amp;&amp; _parmLine.RecId &amp;&amp; _purchLine)        &#123;            vendInvoiceMatchingLine.clear();            vendInvoiceMatchingLine.initExpectedValues(_purchLine, _parmLine);            vendInvoiceMatchingLine.RefTableId = _parmLine.TableId;            vendInvoiceMatchingLine.RefRecId = _parmLine.RecId;            vendInvoiceMatchingLine.insert();        &#125;    &#125;    public void createMarkupTrans(PurchLine _purchLine, VendInvoiceInfoLine _vendInvoiceInfoLine)    &#123;        MarkupTrans markupTrans, markupTransNew;        while select markupTrans            where markupTrans.TransTableId  == _purchLine.TableId                &amp;&amp; markupTrans.TransRecId   == _purchLine.RecId                &amp;&amp; markupTrans.Value        != 0        &#123;            buf2Buf(markupTrans, markupTransNew);            markupTransNew.TransTableId       = _vendInvoiceInfoLine.TableId;            markupTransNew.TransRecId         = _vendInvoiceInfoLine.RecId;            gMarkupTrans.add(markupTransNew);        &#125;    &#125;    public void insertParmSubLine(VendInvoiceInfoSubLine _vendInvoiceInfoSubLine)    &#123;        if (_vendInvoiceInfoSubLine.ReceiveNow == 0)        &#123;            return;        &#125;        gParmSubLineRecordInsertList.add(_vendInvoiceInfoSubLine);    &#125;    public void insertRecordLists()    &#123;        gParmLineRecordInsertList.insertDatabase();        gParmSubLineRecordInsertList.insertDatabase();        gMarkupTrans.insertDatabase();    &#125;    public void createParmLineAndSubLines(PurchLine _purchLine, container _packedSubLinesMap)    &#123;        MapEnumerator           me;        VendInvoiceInfoLine     vendInvoiceInfoLine;        Qty                     newPostingQty;        VendPackingSlipTrans    vendPackingSlipTrans;        Set                     subLineSet      = new Set(Types::Record);        me = Map::create(_packedSubLinesMap).getEnumerator();        while (me.moveNext())        &#123;            RefRecId        vendPackingSlipTransRecId   = me.currentKey();            Qty             qty                         = me.currentValue();            vendPackingSlipTrans            = VendPackingSlipTrans::findRecId(vendPackingSlipTransRecId);            vendPackingSlipTrans.Qty        = qty;            vendPackingSlipTrans.InventQty  = qty;            newPostingQty                   += qty;            subLineSet.add(vendPackingSlipTrans);        &#125;                if (newPostingQty == 0)        &#123;            return;        &#125;        vendInvoiceInfoLine = this.createParmLine(_purchLine, newPostingQty);        this.createParmSubLines(vendInvoiceInfoLine, subLineSet);                gCreateParmTable = true;    &#125;    public VendInvoiceInfoLine createParmLine(PurchLine _purchLine, Qty _receiveNow)    &#123;        VendInvoiceInfoLine vendInvoiceInfoLine;        vendInvoiceInfoLine.Ordering        = DocumentStatus::Invoice;        vendInvoiceInfoLine.TableRefId      = this.getTableRefId();        vendInvoiceInfoLine.DocumentOrigin  = DocumentOrigin::Manual;        vendInvoiceInfoLine.initFromPurchLine(_purchLine);        vendInvoiceInfoLine.defaultRow(_purchLine, null, _receiveNow, _receiveNow);        this.insertParmLine(vendInvoiceInfoLine, _purchLine);                gCreateParmTable = true;        return vendInvoiceInfoLine;    &#125;    public void createParmSubLines(VendInvoiceInfoLine _vendInvoiceInfoLine, Set _subLineSet)    &#123;        VendPackingSlipTrans    vendPackingSlipTrans;        VendInvoiceInfoSubLine  vendInvoiceInfoSubLine;        SetEnumerator           se = _subLineSet.getEnumerator();        while (se.moveNext())        &#123;            vendPackingSlipTrans = se.current();            vendInvoiceInfoSubLine.clear();            vendInvoiceInfoSubLine.initFromLine(_vendInvoiceInfoLine);            vendInvoiceInfoSubLine.initFromVendPackingSlipTrans(vendPackingSlipTrans);            this.insertParmSubLine(vendInvoiceInfoSubLine);        &#125;        if (!_vendInvoiceInfoLine.vendInvoiceInfoSubTable())        &#123;            VendInvoiceInfoSubTable::createFromVendInvoiceInfoLine(_vendInvoiceInfoLine, _vendInvoiceInfoLine.ParmId, gDescription, true);        &#125;    &#125;    public VendInvoiceInfoTable createParmTable()    &#123;        VendInvoiceInfoTable        vendInvoiceInfoTable;        vendInvoiceInfoTable.clear();        vendInvoiceInfoTable.initValue();        vendInvoiceInfoTable.defaultRow(gPurchTable);        vendInvoiceInfoTable.initFromPurchTable(gPurchTable);        vendInvoiceInfoTable.DocumentOrigin         = DocumentOrigin::Manual;        vendInvoiceInfoTable.Num                    = gInvoiceNumber;        vendInvoiceInfoTable.VendInvoiceSaveStatus  = VendInvoiceSaveStatus::Pending;        vendInvoiceInfoTable.Description            = &#x27;Retail POS Sale&#x27;;        vendInvoiceInfoTable.DocumentDate           = gInvoiceDate;        vendInvoiceInfoTable.TransDate              = gInvoiceDate;        vendInvoiceInfoTable.LastMatchVariance      = LastMatchVarianceOptions::OK;        vendInvoiceInfoTable.ParmJobStatus          = ParmJobStatus::Waiting;        vendInvoiceInfoTable.Approved               = NoYes::Yes;        vendInvoiceInfoTable.Approver               = HcmWorker::userId2Worker(curUserId());        vendInvoiceInfoTable.TableRefId             = this.getTableRefId();        vendInvoiceInfoTable.Ordering               = DocumentStatus::Invoice;        vendInvoiceInfoTable.initInvoiceTotals();        vendInvoiceInfoTable.insert();                return vendInvoiceInfoTable;    &#125;    public void createParmSubTable(VendInvoiceInfoTable _vendInvoiceInfoTable)    &#123;        VendInvoiceInfoSubTable::createFromVendInvoiceInfoTable(_vendInvoiceInfoTable, true);    &#125;&#125;","categories":["x++"]},{"title":"Merge the Ledger Account","url":"/2024/12/23/xpp-merge-ledger-account/","content":"The example code as shown below:\npublic static LedgerDimensionAccount generateDefaultDimension(container _conName, container _conValue)&#123;    DimensionAttributeValueSetStorage   valueSetStorage = new DimensionAttributeValueSetStorage();    int                                 i;    DimensionAttribute                  dimensionAttribute;    DimensionAttributeValue             dimensionAttributeValue;    container                           conAttr  = _conName;    container                           conValue = _conValue;    str                                 dimValue;    for (i = 1; i &lt;= conLen(conAttr); i++)    &#123;        dimensionAttribute = dimensionAttribute::findByName(conPeek(conAttr,i));        if (dimensionAttribute.RecId == 0)        &#123;            continue;        &#125;        dimValue = conPeek(conValue,i);        if (dimValue != &quot;&quot;)        &#123;            // The last parameter is &quot;true&quot;. A dimensionAttributeValue record will be created if not found.            dimensionAttributeValue = dimensionAttributeValue::findByDimensionAttributeAndValue(dimensionAttribute, dimValue, false, true);            // Add the dimensionAttibuteValue to the default dimension            valueSetStorage.addItem(dimensionAttributeValue);        &#125;    &#125;    return valueSetStorage.save();&#125;public static LedgerDimensionAccount replaceDefaultDimensionValues(    DimensionDefault    _invoiceDefaultDimension,    DimensionDefault    _purchDefaultDimension,    container           _conName)&#123;    DimensionAttributeValueSetStorage invoiceValueSetStorage    = DimensionAttributeValueSetStorage::find(_invoiceDefaultDimension);    DimensionAttributeValueSetStorage purchValueSetStorage      = DimensionAttributeValueSetStorage::find(_purchDefaultDimension);    for (int i = 1; i &lt;= conLen(_conName); i++)    &#123;        var dimensionAttribute      = DimensionAttribute::findByName(conPeek(_conName, i));        var invoiceDimensionValue   = invoiceValueSetStorage.getDisplayValueByDimensionAttribute(dimensionAttribute.RecId);        var purchDimensionValue     = purchValueSetStorage.getDisplayValueByDimensionAttribute(dimensionAttribute.RecId);        if (purchDimensionValue &amp;&amp; (purchDimensionValue != invoiceDimensionValue))        &#123;            var newDimensionAttributeValue = DimensionAttributeValue::findByDimensionAttributeAndValue(dimensionAttribute, purchDimensionValue, false, true);            invoiceValueSetStorage.removeDimensionAttribute(dimensionAttribute.RecId);            invoiceValueSetStorage.addItem(newDimensionAttributeValue);        &#125;    &#125;        return invoiceValueSetStorage.save();&#125;","categories":["x++"]},{"title":"How to add multiple lookup control to Form Grid","url":"/2025/07/11/xpp-multipleselectionforformgrid/","content":"In some scenarios, we may need to allow users to select multiple values from a lookup within a grid on a form—for example, assigning multiple categories or tags to a line-level record. Out of the box, Dynamics 365 Finance and Operations does not support multi-select lookups directly on grid controls. However, we can achieve this behavior by extending the SysLookupMultiSelectGrid framework.\nStep 1: Create a Custom Class Based on SysLookupMultiSelectGridTo begin, we need to create a custom class that extends SysLookupMultiSelectGrid. This class will encapsulate the logic for initializing the lookup, storing selected values, and writing them back to the grid’s data source.\nHere are the key methods you should implement:\n\ninit(): Register the lookup override and capture context such as the caller data source and field.\n\nlookup(FormStringControl _callerControl): Open the lookup form and load existing values into the selection. After the user makes a selection, update the data source field.\n\ngetSelected(): Return the container of selected record IDs.\n\nsetSelected(): Persist the selected values into a specific field (usually a semicolon-delimited string field).\n\nconstruct(…): A static method to initialize the custom multi-select lookup instance.\n\n\nBy implementing these methods, your custom control can support seamless multi-selection directly from the form grid.\n/// &lt;summary&gt;/// Willie Yao - 07/07/2025/// HMLookupMultiSelectGridOrderCategory/// &lt;/summary&gt;class HMLookupMultiSelectGridOrderCategory extends SysLookupMultiSelectGrid&#123;    FormDataSource              callerDataSource;    FieldId                     callerFieldId;    #define.Spliter(&#x27;;&#x27;)    /// &lt;summary&gt;    /// Willie Yao - 07/07/2025    /// getSelected    /// &lt;/summary&gt;    /// &lt;returns&gt;container&lt;/returns&gt;    public container getSelected()    &#123;        Array       markedRecords;        Common      common;        int         i;        int         recordsMarked = 0;        formDS      = formRun.dataSource();        selectedId  = conNull();        selectedStr = conNull();        for (common = getFirstSelection(formDS); common; common = formDS.getNext())        &#123;            recordsMarked++;        &#125;        if (recordsMarked &gt; 0)        &#123;            markedRecords = formDS.recordsMarked();            for (i = 1; i &lt;= markedRecords.lastIndex(); i++)            &#123;                formDS      = formRun.dataSource();                formDS.setPosition(markedRecords.value(i));                common      = formDS.cursor();                selectedId  += common.RecId;                selectedStr += common.(defaultSelectFieldId);            &#125;        &#125;        return selectedId;    &#125;    /// &lt;summary&gt;    /// Willie Yao - 07/07/2025    /// init    /// &lt;/summary&gt;    public void init()    &#123;        callingControlId.registerOverrideMethod(methodStr(FormStringControl, lookup), methodStr(HMLookupMultiSelectGridOrderCategory, lookup), this);        callerDataSource    = callingControlId.formRun().dataSource(callingControlId.fieldBinding().tableName());        callerFieldId       = callingControlId.fieldBinding().fieldId();    &#125;    /// &lt;summary&gt;    /// Willie Yao - 07/07/2025    /// lookup    /// &lt;/summary&gt;    /// &lt;param name=&quot;_callerControl&quot;&gt;FormStringControl&lt;/param&gt;    public void lookup(FormStringControl _callerControl)    &#123;        FormDataSource  formDataSource;        Common          callerRecord;         if (callerDataSource)        &#123;            selectedId      = conNull();            selectedStr     = conNull();            callerRecord    = callerDataSource.cursor();             if (callerRecord.RecId)            &#123;                HMSpiffs spiffs = callerRecord;                container con = str2con(spiffs.OrderCategory, &#x27;;&#x27;, false);                int i;                for (i = 1; i &lt;= conLen(con); i++)                &#123;                    sunTAFSalesCategory salesCategory = sunTAFSalesCategory::find(conPeek(con, i));                    selectedId += salesCategory.RecId;                    selectedStr += salesCategory.SalesCategoryID;                &#125;            &#125;            else            &#123;                if (callerRecord.validateWrite())                &#123;                    callerRecord.write();                &#125;                else                &#123;                    return;                &#125;            &#125;        &#125;         this.run();         if (callerDataSource)        &#123;            callerRecord.(callerFieldId)    = con2Str(selectedStr, #Spliter);            formDataSource                  = callerRecord.dataSource();            formDataSource.refresh();        &#125;         _callerControl.modified();    &#125;    /// &lt;summary&gt;    /// Willie Yao - 07/07/2025    /// setSelected    /// &lt;/summary&gt;    public void setSelected()    &#123;        Common          callerRecord;         if (callerDataSource)        &#123;            callerRecord    = callerDataSource.cursor();             if (callerRecord)            &#123;                HMSpiffs spiffs = callerRecord;                spiffs.OrderCategory = con2Str(selectedStr, &#x27;;&#x27;);            &#125;        &#125;    &#125;    /// &lt;summary&gt;    /// Willie Yao - 07/07/2025    /// construct    /// &lt;/summary&gt;    /// &lt;param name=&quot;_ctrlId&quot;&gt;ctrlId&lt;/param&gt;    /// &lt;param name=&quot;_query&quot;&gt;query&lt;/param&gt;    /// &lt;param name=&quot;_selectField&quot;&gt;selectField&lt;/param&gt;    /// &lt;returns&gt;HMLookupMultiSelectGridOrderCategory&lt;/returns&gt;    public static HMLookupMultiSelectGridOrderCategory construct(        FormControl _ctrlId,        Query       _query,        container   _selectField = conNull())    &#123;        HMLookupMultiSelectGridOrderCategory lookupMultiSelectControl;         lookupMultiSelectControl = new HMLookupMultiSelectGridOrderCategory();        lookupMultiSelectControl.parmCallingControl(_ctrlId);        lookupMultiSelectControl.parmCallingControlId(_ctrlId);        lookupMultiSelectControl.parmQuery(_query);        lookupMultiSelectControl.parmSelectField(_selectField);        lookupMultiSelectControl.init();         return lookupMultiSelectControl;    &#125;&#125;\n\nStep 2: Use the Lookup Control in the Form GridOnce the custom lookup class is ready, the next step is to integrate it into the form grid where multi-selection is required.\nIn the FormControl method override (usually on the lookup() method of the relevant control), you can instantiate your custom lookup using the construct() method.\nFor example:\nHMLookupMultiSelectGridOrderCategory::construct(MainGrid_OrderCategory, query, con);\n\n\nMainGrid_OrderCategory is the name of the string control (usually bound to a field like OrderCategory) on the form grid.\n\nquery is a standard Query object used to define the records shown in the lookup.\n\ncon is a container specifying which field(s) to select and return from the lookup records.\n\n\nThis setup allows the form to display a multi-select lookup when users interact with the field in the grid, enabling them to choose multiple entries and store them in a semicolon-delimited format (or another structure as needed).\n","categories":["x++"],"tags":["Lookup","Multiple Selection Lookup","Form","Grid"]},{"title":"How To Develop A D365 Number Sequence","url":"/2025/07/11/xpp-numbersequencedevelop/","content":"In Dynamics 365 Finance and Operations, number sequences are essential for generating unique identifiers for business records, such as orders, transactions, or custom entities. In this blog, we’ll walk through how to develop a custom number sequence module step by step.\nStep 1: Create a Custom Number Sequence ClassThe first step is to create a class that extends NumberSeqApplicationModule. This class defines the number sequence logic and configuration.\nHere’s an example:\n/// &lt;summary&gt;/// HM_SUN-034204_EXT-00189 SPIFF workspace/// Willie Yao - 07/07/2025/// HMSpiffsIdNumSeq/// &lt;/summary&gt;internal final class HMSpiffsIdNumSeq extends NumberSeqApplicationModule&#123;    /// &lt;summary&gt;    /// Subscribe to global number sequence module registration    /// &lt;/summary&gt;    /// &lt;param name=&quot;numberSeqModuleNamesMap&quot;&gt;numberSeqModuleNamesMap&lt;/param&gt;    [SubscribesTo(classstr(NumberSeqGlobal), delegatestr(NumberSeqGlobal, buildModulesMapDelegate))]    static void buildModulesMapSubsciber(Map numberSeqModuleNamesMap)    &#123;        NumberSeqGlobal::addModuleToMap(classnum(HMSpiffsIdNumSeq), numberSeqModuleNamesMap);    &#125;    /// &lt;summary&gt;    /// Return the number sequence module    /// &lt;/summary&gt;    /// &lt;returns&gt;NumberSeqModule&lt;/returns&gt;    public NumberSeqModule numberSeqModule()    &#123;        return NumberSeqModule::CRM;    &#125;    /// &lt;summary&gt;    /// Load number sequence datatype configuration    /// &lt;/summary&gt;    protected void loadModule()    &#123;        NumberSeqDatatype datatype = NumberSeqDatatype::construct();        datatype.parmDatatypeId(extendedTypeNum(HMSpiffsId));        datatype.parmReferenceHelp(literalStr(&quot;@HM:HMTheSPIFFIdentificationReference&quot;));        datatype.parmWizardIsContinuous(false);        datatype.parmWizardIsManual(NoYes::No);        datatype.parmWizardFetchAheadQty(10);        datatype.parmWizardIsChangeDownAllowed(NoYes::No);        datatype.parmWizardIsChangeUpAllowed(NoYes::No);        datatype.parmSortField(1);        datatype.addParameterType(NumberSeqParameterType::DataArea, true, false);        this.create(datatype);    &#125;&#125;\n\nKey Points:\n\nThe class must extend NumberSeqApplicationModule.\n\nUse the buildModulesMapSubsciber method to register your module.\n\nImplement loadModule() to define the configuration.\n\nChoose an appropriate NumberSeqModule (e.g., Sales, Inventory).\n\n\nStep 2: Load the Number Sequence from a Parameter FormOnce your number sequence class is defined, you can call it in a form (typically in a loadModule() method for parameter setup):\nHMSpiffsIdNumSeq spiffsIdNumSeq = new HMSpiffsIdNumSeq();spiffsIdNumSeq.load();\n\nThis code is often placed in the loadModule() method of a parameter setup form class (e.g., MyModuleParameters). This ensures that when number sequences are initialized, your custom identifier logic is registered.\nWith these two simple steps, you’ve successfully extended D365FO with a custom number sequence. This is especially useful for custom business scenarios where the out-of-box sequences don’t meet your needs.\nIf you need to integrate this with forms, workflows, or auto-numbering during record creation, you can take it a step further by using the NumberSeqReference framework.\n","categories":["x++"],"tags":["NumberSeq"]},{"title":"Query On-Hand inventory using specific inventory-dimensions","url":"/2025/07/08/xpp-onhandinvent/","content":"InventDimOnhandUsing the class InventDimOnhand, you can determine the on-hand inventory of articles and&#x2F;or specific inventory-dimensions. The following job determines the inventory for a specific item and a specific inventlocation. This is grouped per color.\nstatic void getInventOnhandExample(Args _args)&#123;    ItemId itemId;    InventDimOnHand inventDimOnHand;    InventDimParm inventDimParmOnHandLevel;    InventDimOnHandIterator inventDimOnHandIterator;    InventDimOnHandMember inventDimOnHandMember;    InventDim inventDim;    InventDim inventDimCriteria;    InventDimParm inventDimParmCriteria;    // Item: Query specific item    itemId = &quot;DMO003&quot;;        // inventDimCriteria: Apply ranges    inventDimCriteria.wmsLocationId             = &quot;12-1&quot;;    inventDimCriteria.InventBatchId             = &quot;DMOBatch001&quot;;    // inventDimParmCriteria: should values from inventDimCriteria be used?    inventDimParmCriteria.ItemIdFlag            = false;    inventDimParmCriteria.InventSiteIdFlag      = false;    inventDimParmCriteria.InventLocationIdFlag  = false;    inventDimParmCriteria.wmsLocationIdFlag     = true;     // wmsLocationId from inventDimCriteria will be used    inventDimParmCriteria.wmsPalletIdFlag       = false;    inventDimParmCriteria.InventBatchIdFlag     = false;    // inventBatchId from inventDimCriteria will not be used    inventDimParmCriteria.InventSerialIdFlag    = false;    inventDimParmCriteria.ConfigIdFlag          = false;    inventDimParmCriteria.InventSizeIdFlag      = false;    inventDimParmCriteria.InventColorIdFlag     = false;    inventDimParmCriteria.InventStyleIdFlag     = false;    // inventDimParmOnHandLevel: Which dimensions should be used to group for?    // inventDimParmOnHandLevel necessary for inventDimOnHandLevel::DimParm    inventDimParmOnHandLevel.ItemIdFlag            = true;      // necessary    inventDimParmOnHandLevel.InventSiteIdFlag      = false;    inventDimParmOnHandLevel.InventLocationIdFlag  = false;    inventDimParmOnHandLevel.wmsLocationIdFlag     = false;    inventDimParmOnHandLevel.wmsPalletIdFlag       = false;    inventDimParmOnHandLevel.InventBatchIdFlag     = false;    inventDimParmOnHandLevel.InventSerialIdFlag    = false;    inventDimParmOnHandLevel.ConfigIdFlag          = false;    inventDimParmOnHandLevel.InventSizeIdFlag      = false;    inventDimParmOnHandLevel.InventColorIdFlag     = true;      // group by color    inventDimParmOnHandLevel.InventStyleIdFlag     = false;    inventDimOnHand = InventDimOnHand::newAvailPhysical(itemId,                                                        inventDimCriteria,                                                        inventDimParmCriteria,                                                        InventDimOnHandLevel::DimParm,                                                        inventDimParmOnHandLevel);    inventDimOnHandIterator = inventDimOnHand.onHandIterator();    while (inventDimOnHandIterator.more())    &#123;        inventDimOnHandMember = inventDimOnHandIterator.value();        inventDim = InventDim::find(inventDimOnHandMember.parmInventDimId());        info(con2Str([  inventDimOnHandMember.parmItemId(),                        inventDim.InventSiteId,                        inventDim.InventLocationId,                        inventDim.wmsLocationId,                        inventDim.wmsPalletId,                        inventDim.InventBatchId,                        inventDim.InventSerialId,                        inventDim.ConfigId,                        inventDim.InventSizeId,                        inventDim.InventColorId,                        inventDim.InventStyleId,                        inventDimOnHandMember.parmInventQty()]));        inventDimOnHandIterator.next();    &#125;&#125;\n\nInventOnHandBelow function returns onhand qty of item. You can further filter on hand qty of the item for a location by passing invent location id as its optional parameter.\ndisplay InventQtyOnHand qtyOnHand(InventLocationId _inventLocationId = &#x27;&#x27;)&#123;    InventOnHand inventQtyOnHand;    inventQtyOnHand = InventOnHand::newItemId(this.ItemId);    if (_inventLocationId)        inventQtyOnHand.parmInventLocationId(_inventLocationId);    return inventQtyOnHand.availPhysical();&#125;","categories":["x++"]},{"title":"Open in Microsoft Office","url":"/2025/01/18/xpp-open-in-office/","content":"Operation StepThe first step is to implement the OfficeIMenuCustomizer and OfficeIGenerateWorkbookCustomExporter.\n\n\nThe example code is as follows:\n\n\n\n\nFilter SettingDo not use the Recid of the primary table as the filter condition. This will inevitably require the Recid of the primary table to be released, but this will cause an insertion problem for the data entity: since RecId is the primary key of the primary table, it will make an insertion error regardless of any field entered, and will not be able to skip validation.\nIn this case, you can only use other unique keys instead, but many unique indexes contain multiple fields, so you need to create a computed column in the data entity and then construct a computed column field from the multiple fields of the unique index.\n","categories":["x++"]},{"title":"Reverse customer transaction in X++","url":"/2025/07/11/xpp-reversaltrans/","content":"\nReprinted from: https://community.dynamics.com/blogs/post/?postid=d7f28166-cd5f-469c-979c-4dc412212af1\n\nPurposeThe purpose of this document is to demonstrate how we can reverse a posted customer transaction through X++. The code below can be used as a script to automate reversal of posted customer transactions.\nProductDynamics 365 for Finance and Operations.\nDevelopmentCodeclass MAKCustTransReversal extends TransactionReversal_Cust&#123;    public static MAKCustTransReversal construct()    &#123;        return new MAKCustTransReversal();    &#125;    public boolean showDialog()    &#123;        return false;    &#125;    public static void main(Args _args)    &#123;        CustTrans custTrans;        MAKCustTransReversal makCustTransReversal;        ReasonTable reasonTable;        ReasonCode reasonCode;        ReasonRefRecID reasonRefRecID;        InvoiceId invoiceId;        Args args;        ;        invoiceId = &quot;3392&quot;;        reasonCode = &quot;ERROR&quot;;                reasonTable = ReasonTable::find(reasonCode);        reasonRefRecID = ReasonTableRef::createReasonTableRef(            reasonTable.Reason, reasonTable.Description);        custTrans = CustTrans::findFromInvoice(invoiceId);                    if (custTrans.RecId &amp;&amp; !custTrans.LastSettleVoucher)        &#123;            args = new Args();            args.record(custTrans);            makCustTransReversal = MAKCustTransReversal::construct();            makCustTransReversal.parmReversalDate(systemDateGet());            makCustTransReversal.parmReasonRefRecId(reasonRefRecID);            makCustTransReversal.reversal(args);                        info(strFmt(&quot;%1 %2 %3 %4 reversed.&quot;,                custTrans.Voucher,                custTrans.TransDate,                custTrans.Invoice,                custTrans.Txt));        &#125;            &#125;&#125;","categories":["x++"],"tags":["CustTrans","VendTrans","Reversal"]},{"title":"加密存储敏感信息","url":"/2025/03/29/%E5%8A%A0%E5%AF%86%E5%AD%98%E5%82%A8%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF/","content":"\n本篇为大家介绍一个加密存储数据到 OptionPane 的案例。\n\n案例背景AI 应用开发需要调用大模型开放的接口，API Key 便是必不可少的（以下使用 deepseek-v3 示范）。\n\n关于如何获取且调用 deepseek 的 api key，可以访问官方文档 首次调用 Deepseek API Docs，这里不再赘述。\n\n在集成 AI 到 VSIX 扩展应用过程中，如何存储且获取 API Key 是首先要考虑的，关键的需求如下：\n\nAPI Key 不可明文存储；\nAPI Key 不可明文展示；\n需要是一个全局变量，不可直接在源代码中声明使用；\n用户可以随时编辑。\n\n案例解析首先要解决的是：不可直接存储明文，这就需要在存储 API key 到 OptionPane 之前对用户输入的数据进行加密。\npublic static string EncrySecureString(SecureString secureString)&#123;\tbyte[] encryptedData = ProtectedData.Protect(\t\tEncoding.UTF8.GetBytes(ToInsecureString(secureString)),\t\toptionEntropy: null,\t\tscope: DataProtectionScope.CurrentUser\t);&#125;\n\n而在调用 API 时则需要先获取存储在全局的加密数据，然后解密利用解密后的数据向 deepseek 大模型发送请求。\npublic static SecureString DecryptToSecureString(string encryptedBase64)&#123;\tbyte[] encryptedBytes = Covert.FromBase64String(encryptedBase64);\tbyte[] decryptedBytes = ProtectedData.Unprotect(\t\tencryptedBytes,\t\toptionEntropy: null,\t\tscope: DataProtectionScope.CurrentUser\t);\treturn ToSecureString(Encoding.UTF8.GetString(decryptedBytes));&#125;\n\n其次不可直接将存储在全局的数据直接展示给用户，应当类似 Password 的风格，如下图：\n\n\nVSIX 提供了 OptionPane 接口用于存储全局的数据，用户可导航至 Tools &gt; Option 找到 Visual Studio IDE 的所有全局配置标签页，如下图：\n\n\n注\n\n最后需要注意明文不可在代码内存中保留太长时间，这意味着在用户输入 API key 时，不可以直接使用 WPF.textbox 以普通字符串的形式接收用户输入的值，可以使用 SecureString 接收用户的输入值。在 C# 中，SecureString 是一种用于安全存储敏感数据（如密码、密钥等）的特殊字符串类型。其核心设计目标是通过加密和内存管理机制，降低敏感数据在内存中暴露的风险。而在请求发出后&#x2F;时，应当立刻清理内存中的明敏感数据。这需要使用 byte[] 存储解密后的数据(在 C# 中普通字符串无法被安全地擦除)。最大的减少作用域，并且利用 Array.Clear() 清理 byte[] 数据。\n\n","categories":["c#"]}]